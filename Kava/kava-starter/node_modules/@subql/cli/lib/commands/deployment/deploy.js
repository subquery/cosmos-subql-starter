"use strict";
// Copyright 2020-2022 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const core_1 = require("@oclif/core");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const cli_ux_1 = tslib_1.__importDefault(require("cli-ux"));
const inquirer_1 = tslib_1.__importDefault(require("inquirer"));
const constants_1 = require("../../constants");
const deploy_controller_1 = require("../../controller/deploy-controller");
const utils_1 = require("../../utils");
const ACCESS_TOKEN_PATH = path_1.default.resolve(process.env.HOME, '.subql/SUBQL_ACCESS_TOKEN');
class Deploy extends core_1.Command {
    async run() {
        const { flags } = await this.parse(Deploy);
        let { dict, endpoint, indexerVersion, ipfsCID, org, projectName, queryVersion } = flags;
        const authToken = await (0, utils_1.checkToken)(process.env.SUBQL_ACCESS_TOKEN, ACCESS_TOKEN_PATH);
        org = await (0, utils_1.valueOrPrompt)(org, 'Enter organisation', 'Organisation is required');
        projectName = await (0, utils_1.valueOrPrompt)(projectName, 'Enter project name', 'Project name is required');
        ipfsCID = await (0, utils_1.valueOrPrompt)(ipfsCID, 'Enter IPFS CID', 'IPFS CID is required');
        const validator = await (0, deploy_controller_1.ipfsCID_validate)(ipfsCID, authToken, constants_1.ROOT_API_URL_PROD);
        queryVersion = (0, utils_1.addV)(queryVersion);
        indexerVersion = (0, utils_1.addV)(indexerVersion);
        if (!validator.valid) {
            throw new Error(chalk_1.default.bgRedBright('Invalid IPFS CID'));
        }
        if (!endpoint) {
            const validateEndpoint = (0, deploy_controller_1.processEndpoints)(await (0, deploy_controller_1.networkEndpoints)(constants_1.ROOT_API_URL_PROD), validator.chainId);
            if (!flags.useDefaults) {
                endpoint = await (0, utils_1.promptWithDefaultValues)(cli_ux_1.default, 'Enter endpoint', validateEndpoint, null, true);
            }
            else if (validateEndpoint) {
                endpoint = validateEndpoint;
            }
            else {
                throw new Error(chalk_1.default.red('Please use --endpoint flag when using a custom Endpoint'));
            }
        }
        const queryAD = {
            unsafe: flags.queryUnsafe,
            subscription: flags.querySubscription,
            queryTimeout: flags.queryTimeout,
            maxConnection: flags.queryMaxConnection,
            Aggregate: flags.queryAggregate,
        };
        const indexerAD = {
            unsafe: flags.indexerUnsafe,
            batchSize: flags.indexerBatchSize,
            subscription: flags.indexerSubscription,
            historicalData: !flags.disableHistorical,
            workers: flags.indexerWorkers,
        };
        if (!dict) {
            const validateDictEndpoint = (0, deploy_controller_1.processEndpoints)(await (0, deploy_controller_1.dictionaryEndpoints)(constants_1.ROOT_API_URL_PROD), validator.chainId);
            if (!flags.useDefaults && !validateDictEndpoint) {
                dict = await (0, utils_1.promptWithDefaultValues)(cli_ux_1.default, 'Enter dictionary', validateDictEndpoint, null, false);
            }
            else {
                dict = validateDictEndpoint;
            }
        }
        if (!indexerVersion) {
            try {
                const indexerVersions = await (0, deploy_controller_1.imageVersions)(validator.manifestRunner.node.name, validator.manifestRunner.node.version, authToken, constants_1.ROOT_API_URL_PROD);
                if (!flags.useDefaults) {
                    const response = await (0, utils_1.promptWithDefaultValues)(inquirer_1.default, 'Enter indexer version', null, indexerVersions, true);
                    indexerVersion = response;
                }
                else {
                    indexerVersion = indexerVersions[0];
                }
            }
            catch (e) {
                throw new Error(chalk_1.default.bgRedBright('Indexer version is required'));
            }
        }
        if (!queryVersion) {
            try {
                const queryVersions = await (0, deploy_controller_1.imageVersions)(validator.manifestRunner.query.name, validator.manifestRunner.query.version, authToken, constants_1.ROOT_API_URL_PROD);
                if (!flags.useDefaults) {
                    const response = await (0, utils_1.promptWithDefaultValues)(inquirer_1.default, 'Enter query version', null, queryVersions, true);
                    queryVersion = response;
                }
                else {
                    queryVersion = queryVersions[0];
                }
            }
            catch (e) {
                throw new Error(chalk_1.default.bgRedBright('Indexer version is required'));
            }
        }
        const projectInfo = await (0, deploy_controller_1.projectsInfo)(authToken, org, projectName, constants_1.ROOT_API_URL_PROD, flags.type);
        if (projectInfo !== undefined) {
            await (0, deploy_controller_1.redeploy)(org, projectName, projectInfo.id, authToken, ipfsCID, endpoint, dict, indexerVersion, queryVersion, queryAD, indexerAD, constants_1.ROOT_API_URL_PROD);
            this.log(`Project: ${projectName} has been re-deployed`);
        }
        else {
            this.log('Deploying SubQuery project to Hosted Service');
            const deploymentOutput = await (0, deploy_controller_1.deployToHostedService)(org, projectName, authToken, ipfsCID, indexerVersion, queryVersion, endpoint, flags.type, dict, queryAD, indexerAD, constants_1.ROOT_API_URL_PROD).catch((e) => this.error(e));
            this.log(`Project: ${deploymentOutput.projectKey}
      \nStatus: ${chalk_1.default.blue(deploymentOutput.status)}
      \nDeploymentID: ${deploymentOutput.id}
      \nDeployment Type: ${deploymentOutput.type}
      \nIndexer version: ${deploymentOutput.indexerImage}
      \nQuery version: ${deploymentOutput.queryImage}
      \nEndpoint: ${deploymentOutput.endpoint}
      \nDictionary Endpoint: ${deploymentOutput.dictEndpoint}
      \nQuery URL: ${deploymentOutput.queryUrl}
      \nProject URL: ${constants_1.BASE_PROJECT_URL}/project/${deploymentOutput.projectKey}
      \nAdvanced Settings for Query: ${JSON.stringify(deploymentOutput.configuration.config.query)}
      \nAdvanced Settings for Indexer: ${JSON.stringify(deploymentOutput.configuration.config.indexer)}
      `);
        }
    }
}
Deploy.description = 'Deployment to hosted service';
Deploy.flags = {
    org: core_1.Flags.string({ description: 'Enter organization name' }),
    projectName: core_1.Flags.string({ description: 'Enter project name' }),
    ipfsCID: core_1.Flags.string({ description: 'Enter IPFS CID' }),
    type: core_1.Flags.enum({ options: ['stage', 'primary'], default: constants_1.DEFAULT_DEPLOYMENT_TYPE, required: false }),
    indexerVersion: core_1.Flags.string({ description: 'Enter indexer-version', required: false }),
    queryVersion: core_1.Flags.string({ description: 'Enter query-version', required: false }),
    dict: core_1.Flags.string({ description: 'Enter dictionary', required: false }),
    endpoint: core_1.Flags.string({ description: 'Enter endpoint', required: false }),
    //indexer set up flags
    indexerUnsafe: core_1.Flags.boolean({ description: 'Enable indexer unsafe', required: false }),
    indexerBatchSize: core_1.Flags.integer({ description: 'Enter batchSize from 1 to 30', required: false }),
    indexerSubscription: core_1.Flags.boolean({ description: 'Enable Indexer subscription', required: false }),
    disableHistorical: core_1.Flags.boolean({ description: 'Disable Historical Data', required: false }),
    indexerWorkers: core_1.Flags.integer({ description: 'Enter worker threads from 1 to 30', required: false }),
    //query flags
    queryUnsafe: core_1.Flags.boolean({ description: 'Enable indexer unsafe', required: false }),
    querySubscription: core_1.Flags.boolean({ description: 'Enable Query subscription', required: false }),
    queryTimeout: core_1.Flags.integer({ description: 'Enter timeout from 1000ms to 60000ms', required: false }),
    queryMaxConnection: core_1.Flags.integer({ description: 'Enter MaxConnection from 1 to 10', required: false }),
    queryAggregate: core_1.Flags.boolean({ description: 'Enable Aggregate', required: false }),
    useDefaults: core_1.Flags.boolean({
        char: 'd',
        description: 'Use default values for indexerVersion, queryVersion, dictionary, endpoint',
        required: false,
    }),
};
exports.default = Deploy;
//# sourceMappingURL=deploy.js.map
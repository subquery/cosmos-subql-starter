/**
 * @name u8aToNumber
 * @summary Creates a number from a Uint8Array object.
 */
export function u8aToNumber(value, { isNegative = false } = {}) {
    const count = value.length;
    if (isNegative) {
        let result = 0;
        switch (count) {
            case 0:
                return 0;
            case 1:
                result = value[0] ^ 255;
                break;
            case 2:
                result = (value[0] + (value[1] << 8)) ^ 65535;
                break;
            case 3:
                result = (value[0] + (value[1] << 8) + (value[2] << 16)) ^ 16777215;
                break;
            case 4:
                // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to
                // 32-bit, in the case where the top-most bit is set this yields a negative value
                result = (value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295;
                break;
            case 5:
                result = ((value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295) + ((value[4] ^ 0xff) * 4294967296);
                break;
            case 6:
                result = ((value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216)) ^ 4294967295) + (((value[4] + (value[5] << 8)) ^ 65535) * 4294967296);
                break;
            default:
                throw new Error('Value more than 48-bits cannot be reliably converted');
        }
        return (result * -1) - 1;
    }
    switch (count) {
        case 0:
            return 0;
        case 1:
            return value[0];
        case 2:
            return value[0] + (value[1] << 8);
        case 3:
            return value[0] + (value[1] << 8) + (value[2] << 16);
        case 4:
            // for the 3rd byte, we don't << 24 - since JS converts all bitwise operators to
            // 32-bit, in the case where the top-most bit is set this yields a negative value
            return value[0] + (value[1] << 8) + (value[2] << 16) + (value[3] * 16777216);
        case 5:
            return value[0] + (value[1] << 8) + (value[2] << 16) + ((value[3] + (value[4] << 8)) * 16777216);
        case 6:
            return value[0] + (value[1] << 8) + (value[2] << 16) + ((value[3] + (value[4] << 8) + (value[5] << 16)) * 16777216);
        default:
            throw new Error('Value more than 48-bits cannot be reliably converted');
    }
}

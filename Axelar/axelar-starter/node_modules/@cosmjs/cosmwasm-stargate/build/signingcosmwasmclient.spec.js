"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/naming-convention */
const amino_1 = require("@cosmjs/amino");
const crypto_1 = require("@cosmjs/crypto");
const encoding_1 = require("@cosmjs/encoding");
const proto_signing_1 = require("@cosmjs/proto-signing");
const stargate_1 = require("@cosmjs/stargate");
const utils_1 = require("@cosmjs/utils");
const tx_1 = require("cosmjs-types/cosmos/bank/v1beta1/tx");
const coin_1 = require("cosmjs-types/cosmos/base/v1beta1/coin");
const tx_2 = require("cosmjs-types/cosmos/staking/v1beta1/tx");
const tx_3 = require("cosmjs-types/cosmos/tx/v1beta1/tx");
const tx_4 = require("cosmjs-types/cosmwasm/wasm/v1/tx");
const long_1 = __importDefault(require("long"));
const pako_1 = __importDefault(require("pako"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const signingcosmwasmclient_1 = require("./signingcosmwasmclient");
const testutils_spec_1 = require("./testutils.spec");
describe("SigningCosmWasmClient", () => {
    describe("connectWithSigner", () => {
        it("can be constructed", async () => {
            (0, testutils_spec_1.pendingWithoutWasmd)();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, {
                ...testutils_spec_1.defaultSigningClientOptions,
                prefix: testutils_spec_1.wasmd.prefix,
            });
            expect(client).toBeTruthy();
            client.disconnect();
        });
        it("can be constructed with custom registry", async () => {
            (0, testutils_spec_1.pendingWithoutWasmd)();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const registry = new proto_signing_1.Registry();
            registry.register("/custom.MsgCustom", tx_1.MsgSend);
            const options = { ...testutils_spec_1.defaultSigningClientOptions, prefix: testutils_spec_1.wasmd.prefix, registry: registry };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            expect(client.registry.lookupType("/custom.MsgCustom")).toEqual(tx_1.MsgSend);
            client.disconnect();
        });
    });
    describe("simulate", () => {
        it("works", async () => {
            (0, testutils_spec_1.pendingWithoutWasmd)();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { ...testutils_spec_1.defaultSigningClientOptions, prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const executeContractMsg = {
                typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
                value: tx_4.MsgExecuteContract.fromPartial({
                    sender: testutils_spec_1.alice.address0,
                    contract: testutils_spec_1.deployedHackatom.instances[0].address,
                    msg: (0, encoding_1.toUtf8)(`{"release":{}}`),
                    funds: [],
                }),
            };
            const memo = "Go go go";
            const gasUsed = await client.simulate(testutils_spec_1.alice.address0, [executeContractMsg], memo);
            expect(gasUsed).toBeGreaterThanOrEqual(101000);
            expect(gasUsed).toBeLessThanOrEqual(150000);
            client.disconnect();
        });
    });
    describe("upload", () => {
        it("works", async () => {
            (0, testutils_spec_1.pendingWithoutWasmd)();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { ...testutils_spec_1.defaultSigningClientOptions, prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const wasm = (0, testutils_spec_1.getHackatom)().data;
            const { codeId, originalChecksum, originalSize, compressedChecksum, compressedSize } = await client.upload(testutils_spec_1.alice.address0, wasm, testutils_spec_1.defaultUploadFee);
            expect(originalChecksum).toEqual((0, encoding_1.toHex)((0, crypto_1.sha256)(wasm)));
            expect(originalSize).toEqual(wasm.length);
            expect(compressedChecksum).toMatch(/^[0-9a-f]{64}$/);
            expect(compressedSize).toBeLessThan(wasm.length * 0.5);
            expect(codeId).toBeGreaterThanOrEqual(1);
            client.disconnect();
        });
    });
    describe("instantiate", () => {
        it("works with transfer amount", async () => {
            (0, testutils_spec_1.pendingWithoutWasmd)();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { ...testutils_spec_1.defaultSigningClientOptions, prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const { codeId } = await client.upload(testutils_spec_1.alice.address0, (0, testutils_spec_1.getHackatom)().data, testutils_spec_1.defaultUploadFee);
            const funds = [(0, stargate_1.coin)(1234, "ucosm"), (0, stargate_1.coin)(321, "ustake")];
            const beneficiaryAddress = (0, testutils_spec_1.makeRandomAddress)();
            const { contractAddress, height, gasWanted, gasUsed } = await client.instantiate(testutils_spec_1.alice.address0, codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "My cool label", testutils_spec_1.defaultInstantiateFee, {
                memo: "Let's see if the memo is used",
                funds: funds,
            });
            const wasmClient = await (0, testutils_spec_1.makeWasmClient)(testutils_spec_1.wasmd.endpoint);
            const ucosmBalance = await wasmClient.bank.balance(contractAddress, "ucosm");
            const ustakeBalance = await wasmClient.bank.balance(contractAddress, "ustake");
            expect(ucosmBalance).toEqual(funds[0]);
            expect(ustakeBalance).toEqual(funds[1]);
            expect(height).toBeGreaterThan(0);
            expect(gasWanted).toBeGreaterThan(0);
            expect(gasUsed).toBeGreaterThan(0);
            client.disconnect();
        });
        it("works with admin", async () => {
            (0, testutils_spec_1.pendingWithoutWasmd)();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { ...testutils_spec_1.defaultSigningClientOptions, prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const { codeId } = await client.upload(testutils_spec_1.alice.address0, (0, testutils_spec_1.getHackatom)().data, testutils_spec_1.defaultUploadFee);
            const beneficiaryAddress = (0, testutils_spec_1.makeRandomAddress)();
            const { contractAddress, height, gasWanted, gasUsed } = await client.instantiate(testutils_spec_1.alice.address0, codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "My cool label", testutils_spec_1.defaultInstantiateFee, { admin: testutils_spec_1.unused.address });
            const wasmClient = await (0, testutils_spec_1.makeWasmClient)(testutils_spec_1.wasmd.endpoint);
            const { contractInfo } = await wasmClient.wasm.getContractInfo(contractAddress);
            (0, utils_1.assert)(contractInfo);
            expect(height).toBeGreaterThan(0);
            expect(gasWanted).toBeGreaterThan(0);
            expect(gasUsed).toBeGreaterThan(0);
            expect(contractInfo.admin).toEqual(testutils_spec_1.unused.address);
            client.disconnect();
        });
        it("can instantiate one code multiple times", async () => {
            (0, testutils_spec_1.pendingWithoutWasmd)();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { ...testutils_spec_1.defaultSigningClientOptions, prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const { codeId } = await client.upload(testutils_spec_1.alice.address0, (0, testutils_spec_1.getHackatom)().data, testutils_spec_1.defaultUploadFee);
            const { contractAddress: address1, height, gasWanted, gasUsed, } = await client.instantiate(testutils_spec_1.alice.address0, codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: (0, testutils_spec_1.makeRandomAddress)(),
            }, "contract 1", testutils_spec_1.defaultInstantiateFee);
            const { contractAddress: address2 } = await client.instantiate(testutils_spec_1.alice.address0, codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: (0, testutils_spec_1.makeRandomAddress)(),
            }, "contract 2", testutils_spec_1.defaultInstantiateFee);
            expect(height).toBeGreaterThan(0);
            expect(gasWanted).toBeGreaterThan(0);
            expect(gasUsed).toBeGreaterThan(0);
            expect(address1).not.toEqual(address2);
            client.disconnect();
        });
        it("works with legacy Amino signer", async () => {
            (0, testutils_spec_1.pendingWithoutWasmd)();
            const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { ...testutils_spec_1.defaultSigningClientOptions, prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            // With admin
            await client.instantiate(testutils_spec_1.alice.address0, testutils_spec_1.deployedHackatom.codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: (0, testutils_spec_1.makeRandomAddress)(),
            }, "contract 1", testutils_spec_1.defaultInstantiateFee, { admin: (0, testutils_spec_1.makeRandomAddress)() });
            // Without admin
            await client.instantiate(testutils_spec_1.alice.address0, testutils_spec_1.deployedHackatom.codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: (0, testutils_spec_1.makeRandomAddress)(),
            }, "contract 1", testutils_spec_1.defaultInstantiateFee);
            client.disconnect();
        });
    });
    describe("updateAdmin", () => {
        it("can update an admin", async () => {
            (0, testutils_spec_1.pendingWithoutWasmd)();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { ...testutils_spec_1.defaultSigningClientOptions, prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const { codeId } = await client.upload(testutils_spec_1.alice.address0, (0, testutils_spec_1.getHackatom)().data, testutils_spec_1.defaultUploadFee);
            const beneficiaryAddress = (0, testutils_spec_1.makeRandomAddress)();
            const { contractAddress } = await client.instantiate(testutils_spec_1.alice.address0, codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "My cool label", testutils_spec_1.defaultInstantiateFee, {
                admin: testutils_spec_1.alice.address0,
            });
            const wasmClient = await (0, testutils_spec_1.makeWasmClient)(testutils_spec_1.wasmd.endpoint);
            const { contractInfo: contractInfo1 } = await wasmClient.wasm.getContractInfo(contractAddress);
            (0, utils_1.assert)(contractInfo1);
            expect(contractInfo1.admin).toEqual(testutils_spec_1.alice.address0);
            const { height, gasUsed, gasWanted } = await client.updateAdmin(testutils_spec_1.alice.address0, contractAddress, testutils_spec_1.unused.address, testutils_spec_1.defaultUpdateAdminFee);
            const { contractInfo: contractInfo2 } = await wasmClient.wasm.getContractInfo(contractAddress);
            (0, utils_1.assert)(contractInfo2);
            expect(contractInfo2.admin).toEqual(testutils_spec_1.unused.address);
            expect(height).toBeGreaterThan(0);
            expect(gasWanted).toBeGreaterThan(0);
            expect(gasUsed).toBeGreaterThan(0);
            client.disconnect();
        });
    });
    describe("clearAdmin", () => {
        it("can clear an admin", async () => {
            (0, testutils_spec_1.pendingWithoutWasmd)();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { ...testutils_spec_1.defaultSigningClientOptions, prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const { codeId } = await client.upload(testutils_spec_1.alice.address0, (0, testutils_spec_1.getHackatom)().data, testutils_spec_1.defaultUploadFee);
            const beneficiaryAddress = (0, testutils_spec_1.makeRandomAddress)();
            const { contractAddress } = await client.instantiate(testutils_spec_1.alice.address0, codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "My cool label", testutils_spec_1.defaultInstantiateFee, {
                admin: testutils_spec_1.alice.address0,
            });
            const wasmClient = await (0, testutils_spec_1.makeWasmClient)(testutils_spec_1.wasmd.endpoint);
            const { contractInfo: contractInfo1 } = await wasmClient.wasm.getContractInfo(contractAddress);
            (0, utils_1.assert)(contractInfo1);
            expect(contractInfo1.admin).toEqual(testutils_spec_1.alice.address0);
            const { height, gasUsed, gasWanted } = await client.clearAdmin(testutils_spec_1.alice.address0, contractAddress, testutils_spec_1.defaultClearAdminFee);
            const { contractInfo: contractInfo2 } = await wasmClient.wasm.getContractInfo(contractAddress);
            (0, utils_1.assert)(contractInfo2);
            expect(contractInfo2.admin).toEqual("");
            expect(height).toBeGreaterThan(0);
            expect(gasWanted).toBeGreaterThan(0);
            expect(gasUsed).toBeGreaterThan(0);
            client.disconnect();
        });
    });
    describe("migrate", () => {
        it("works", async () => {
            (0, testutils_spec_1.pendingWithoutWasmd)();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { ...testutils_spec_1.defaultSigningClientOptions, prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const { codeId: codeId1 } = await client.upload(testutils_spec_1.alice.address0, (0, testutils_spec_1.getHackatom)().data, testutils_spec_1.defaultUploadFee);
            const { codeId: codeId2 } = await client.upload(testutils_spec_1.alice.address0, (0, testutils_spec_1.getHackatom)().data, testutils_spec_1.defaultUploadFee);
            const beneficiaryAddress = (0, testutils_spec_1.makeRandomAddress)();
            const { contractAddress } = await client.instantiate(testutils_spec_1.alice.address0, codeId1, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "My cool label", testutils_spec_1.defaultInstantiateFee, {
                admin: testutils_spec_1.alice.address0,
            });
            const wasmClient = await (0, testutils_spec_1.makeWasmClient)(testutils_spec_1.wasmd.endpoint);
            const { contractInfo: contractInfo1 } = await wasmClient.wasm.getContractInfo(contractAddress);
            (0, utils_1.assert)(contractInfo1);
            expect(contractInfo1.admin).toEqual(testutils_spec_1.alice.address0);
            const newVerifier = (0, testutils_spec_1.makeRandomAddress)();
            const { height, gasUsed, gasWanted } = await client.migrate(testutils_spec_1.alice.address0, contractAddress, codeId2, { verifier: newVerifier }, testutils_spec_1.defaultMigrateFee);
            expect(height).toBeGreaterThan(0);
            expect(gasWanted).toBeGreaterThan(0);
            expect(gasUsed).toBeGreaterThan(0);
            const { contractInfo: contractInfo2 } = await wasmClient.wasm.getContractInfo(contractAddress);
            (0, utils_1.assert)(contractInfo2);
            expect({ ...contractInfo2 }).toEqual({
                ...contractInfo1,
                codeId: long_1.default.fromNumber(codeId2, true),
            });
            client.disconnect();
        });
        it("works with legacy Amino signer", async () => {
            (0, testutils_spec_1.pendingWithoutWasmd)();
            const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { ...testutils_spec_1.defaultSigningClientOptions, prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const { codeId: codeId1 } = await client.upload(testutils_spec_1.alice.address0, (0, testutils_spec_1.getHackatom)().data, testutils_spec_1.defaultUploadFee);
            const { codeId: codeId2 } = await client.upload(testutils_spec_1.alice.address0, (0, testutils_spec_1.getHackatom)().data, testutils_spec_1.defaultUploadFee);
            const beneficiaryAddress = (0, testutils_spec_1.makeRandomAddress)();
            const { contractAddress } = await client.instantiate(testutils_spec_1.alice.address0, codeId1, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "My cool label", testutils_spec_1.defaultInstantiateFee, { admin: testutils_spec_1.alice.address0 });
            const wasmClient = await (0, testutils_spec_1.makeWasmClient)(testutils_spec_1.wasmd.endpoint);
            const { contractInfo: contractInfo1 } = await wasmClient.wasm.getContractInfo(contractAddress);
            (0, utils_1.assert)(contractInfo1);
            expect(contractInfo1.admin).toEqual(testutils_spec_1.alice.address0);
            const newVerifier = (0, testutils_spec_1.makeRandomAddress)();
            await client.migrate(testutils_spec_1.alice.address0, contractAddress, codeId2, { verifier: newVerifier }, testutils_spec_1.defaultMigrateFee);
            const { contractInfo: contractInfo2 } = await wasmClient.wasm.getContractInfo(contractAddress);
            (0, utils_1.assert)(contractInfo2);
            expect({ ...contractInfo2 }).toEqual({
                ...contractInfo1,
                codeId: long_1.default.fromNumber(codeId2, true),
            });
            client.disconnect();
        });
    });
    describe("execute", () => {
        it("works", async () => {
            (0, testutils_spec_1.pendingWithoutWasmd)();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { ...testutils_spec_1.defaultSigningClientOptions, prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const { codeId } = await client.upload(testutils_spec_1.alice.address0, (0, testutils_spec_1.getHackatom)().data, testutils_spec_1.defaultUploadFee);
            // instantiate
            const funds = [(0, stargate_1.coin)(233444, "ucosm"), (0, stargate_1.coin)(5454, "ustake")];
            const beneficiaryAddress = (0, testutils_spec_1.makeRandomAddress)();
            const { contractAddress } = await client.instantiate(testutils_spec_1.alice.address0, codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "amazing random contract", testutils_spec_1.defaultInstantiateFee, {
                funds: funds,
            });
            // execute
            const result = await client.execute(testutils_spec_1.alice.address0, contractAddress, { release: {} }, testutils_spec_1.defaultExecuteFee);
            expect(result.height).toBeGreaterThan(0);
            expect(result.gasWanted).toBeGreaterThan(0);
            expect(result.gasUsed).toBeGreaterThan(0);
            const wasmEvent = result.logs[0].events.find((e) => e.type === "wasm");
            (0, utils_1.assert)(wasmEvent, "Event of type wasm expected");
            expect(wasmEvent.attributes).toContain({ key: "action", value: "release" });
            expect(wasmEvent.attributes).toContain({
                key: "destination",
                value: beneficiaryAddress,
            });
            // Verify token transfer from contract to beneficiary
            const wasmClient = await (0, testutils_spec_1.makeWasmClient)(testutils_spec_1.wasmd.endpoint);
            const beneficiaryBalanceUcosm = await wasmClient.bank.balance(beneficiaryAddress, "ucosm");
            expect(beneficiaryBalanceUcosm).toEqual(funds[0]);
            const beneficiaryBalanceUstake = await wasmClient.bank.balance(beneficiaryAddress, "ustake");
            expect(beneficiaryBalanceUstake).toEqual(funds[1]);
            const contractBalanceUcosm = await wasmClient.bank.balance(contractAddress, "ucosm");
            expect(contractBalanceUcosm).toEqual((0, stargate_1.coin)(0, "ucosm"));
            const contractBalanceUstake = await wasmClient.bank.balance(contractAddress, "ustake");
            expect(contractBalanceUstake).toEqual((0, stargate_1.coin)(0, "ustake"));
            client.disconnect();
        });
        it("works with legacy Amino signer", async () => {
            (0, testutils_spec_1.pendingWithoutWasmd)();
            const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { ...testutils_spec_1.defaultSigningClientOptions, prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const { codeId } = await client.upload(testutils_spec_1.alice.address0, (0, testutils_spec_1.getHackatom)().data, testutils_spec_1.defaultUploadFee);
            // instantiate
            const funds = [(0, stargate_1.coin)(233444, "ucosm"), (0, stargate_1.coin)(5454, "ustake")];
            const beneficiaryAddress = (0, testutils_spec_1.makeRandomAddress)();
            const { contractAddress } = await client.instantiate(testutils_spec_1.alice.address0, codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "amazing random contract", testutils_spec_1.defaultInstantiateFee, {
                funds: funds,
            });
            // execute
            const result = await client.execute(testutils_spec_1.alice.address0, contractAddress, { release: {} }, testutils_spec_1.defaultExecuteFee);
            const wasmEvent = result.logs[0].events.find((e) => e.type === "wasm");
            (0, utils_1.assert)(wasmEvent, "Event of type wasm expected");
            expect(wasmEvent.attributes).toContain({ key: "action", value: "release" });
            expect(wasmEvent.attributes).toContain({
                key: "destination",
                value: beneficiaryAddress,
            });
            // Verify token transfer from contract to beneficiary
            const wasmClient = await (0, testutils_spec_1.makeWasmClient)(testutils_spec_1.wasmd.endpoint);
            const beneficiaryBalanceUcosm = await wasmClient.bank.balance(beneficiaryAddress, "ucosm");
            expect(beneficiaryBalanceUcosm).toEqual(funds[0]);
            const beneficiaryBalanceUstake = await wasmClient.bank.balance(beneficiaryAddress, "ustake");
            expect(beneficiaryBalanceUstake).toEqual(funds[1]);
            const contractBalanceUcosm = await wasmClient.bank.balance(contractAddress, "ucosm");
            expect(contractBalanceUcosm).toEqual((0, stargate_1.coin)(0, "ucosm"));
            const contractBalanceUstake = await wasmClient.bank.balance(contractAddress, "ustake");
            expect(contractBalanceUstake).toEqual((0, stargate_1.coin)(0, "ustake"));
            client.disconnect();
        });
    });
    describe("sendTokens", () => {
        it("works with direct signer", async () => {
            (0, testutils_spec_1.pendingWithoutWasmd)();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { ...testutils_spec_1.defaultSigningClientOptions, prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const amount = (0, stargate_1.coins)(7890, "ucosm");
            const beneficiaryAddress = (0, testutils_spec_1.makeRandomAddress)();
            const memo = "for dinner";
            // no tokens here
            const before = await client.getBalance(beneficiaryAddress, "ucosm");
            expect(before).toEqual({
                denom: "ucosm",
                amount: "0",
            });
            // send
            const result = await client.sendTokens(testutils_spec_1.alice.address0, beneficiaryAddress, amount, testutils_spec_1.defaultSendFee, memo);
            (0, stargate_1.assertIsDeliverTxSuccess)(result);
            expect(result.rawLog).toBeTruthy();
            // got tokens
            const after = await client.getBalance(beneficiaryAddress, "ucosm");
            (0, utils_1.assert)(after);
            expect(after).toEqual(amount[0]);
            client.disconnect();
        });
        it("works with legacy Amino signer", async () => {
            (0, testutils_spec_1.pendingWithoutWasmd)();
            const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { ...testutils_spec_1.defaultSigningClientOptions, prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const amount = (0, stargate_1.coins)(7890, "ucosm");
            const beneficiaryAddress = (0, testutils_spec_1.makeRandomAddress)();
            const memo = "for dinner";
            // no tokens here
            const before = await client.getBalance(beneficiaryAddress, "ucosm");
            expect(before).toEqual({
                denom: "ucosm",
                amount: "0",
            });
            // send
            const result = await client.sendTokens(testutils_spec_1.alice.address0, beneficiaryAddress, amount, testutils_spec_1.defaultSendFee, memo);
            (0, stargate_1.assertIsDeliverTxSuccess)(result);
            expect(result.rawLog).toBeTruthy();
            // got tokens
            const after = await client.getBalance(beneficiaryAddress, "ucosm");
            (0, utils_1.assert)(after);
            expect(after).toEqual(amount[0]);
            client.disconnect();
        });
    });
    describe("signAndBroadcast", () => {
        describe("direct mode", () => {
            it("works", async () => {
                (0, testutils_spec_1.pendingWithoutWasmd)();
                const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, {
                    ...testutils_spec_1.defaultSigningClientOptions,
                    prefix: testutils_spec_1.wasmd.prefix,
                });
                const msgDelegateTypeUrl = "/cosmos.staking.v1beta1.MsgDelegate";
                const msg = tx_2.MsgDelegate.fromPartial({
                    delegatorAddress: testutils_spec_1.alice.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: (0, stargate_1.coin)(1234, "ustake"),
                });
                const msgAny = {
                    typeUrl: msgDelegateTypeUrl,
                    value: msg,
                };
                const fee = {
                    amount: (0, stargate_1.coins)(2000, "ucosm"),
                    gas: "180000", // 180k
                };
                const memo = "Use your power wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                (0, stargate_1.assertIsDeliverTxSuccess)(result);
                client.disconnect();
            });
            it("works with auto gas", async () => {
                (0, testutils_spec_1.pendingWithoutWasmd)();
                const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, {
                    ...testutils_spec_1.defaultSigningClientOptions,
                    prefix: testutils_spec_1.wasmd.prefix,
                    gasPrice: testutils_spec_1.defaultGasPrice,
                });
                const msgDelegateTypeUrl = "/cosmos.staking.v1beta1.MsgDelegate";
                const msg = tx_2.MsgDelegate.fromPartial({
                    delegatorAddress: testutils_spec_1.alice.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: (0, stargate_1.coin)(1234, "ustake"),
                });
                const msgAny = {
                    typeUrl: msgDelegateTypeUrl,
                    value: msg,
                };
                const memo = "Use your power wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.alice.address0, [msgAny], "auto", memo);
                (0, stargate_1.assertIsDeliverTxSuccess)(result);
                client.disconnect();
            });
            it("works with a modifying signer", async () => {
                (0, testutils_spec_1.pendingWithoutWasmd)();
                const wallet = await testutils_spec_1.ModifyingDirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, {
                    prefix: testutils_spec_1.wasmd.prefix,
                });
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, {
                    ...testutils_spec_1.defaultSigningClientOptions,
                    prefix: testutils_spec_1.wasmd.prefix,
                });
                const msgDelegateTypeUrl = "/cosmos.staking.v1beta1.MsgDelegate";
                const msg = tx_2.MsgDelegate.fromPartial({
                    delegatorAddress: testutils_spec_1.alice.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: (0, stargate_1.coin)(1234, "ustake"),
                });
                const msgAny = {
                    typeUrl: msgDelegateTypeUrl,
                    value: msg,
                };
                const fee = {
                    amount: (0, stargate_1.coins)(2000, "ucosm"),
                    gas: "180000", // 180k
                };
                const memo = "Use your power wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                (0, stargate_1.assertIsDeliverTxSuccess)(result);
                await (0, utils_1.sleep)(500);
                const searchResult = await client.getTx(result.transactionHash);
                (0, utils_1.assert)(searchResult, "Must find transaction");
                const tx = (0, proto_signing_1.decodeTxRaw)(searchResult.tx);
                // From ModifyingDirectSecp256k1HdWallet
                expect(tx.body.memo).toEqual("This was modified");
                expect({ ...tx.authInfo.fee.amount[0] }).toEqual((0, stargate_1.coin)(3000, "ucosm"));
                expect(tx.authInfo.fee.gasLimit.toNumber()).toEqual(333333);
                client.disconnect();
            });
        });
        describe("legacy Amino mode", () => {
            it("works with bank MsgSend", async () => {
                (0, testutils_spec_1.pendingWithoutWasmd)();
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, {
                    ...testutils_spec_1.defaultSigningClientOptions,
                    prefix: testutils_spec_1.wasmd.prefix,
                });
                const msgSend = {
                    fromAddress: testutils_spec_1.alice.address0,
                    toAddress: (0, testutils_spec_1.makeRandomAddress)(),
                    amount: (0, stargate_1.coins)(1234, "ucosm"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.bank.v1beta1.MsgSend",
                    value: msgSend,
                };
                const fee = {
                    amount: (0, stargate_1.coins)(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your tokens wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                (0, stargate_1.assertIsDeliverTxSuccess)(result);
                client.disconnect();
            });
            it("works with staking MsgDelegate", async () => {
                (0, testutils_spec_1.pendingWithoutWasmd)();
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, {
                    ...testutils_spec_1.defaultSigningClientOptions,
                    aminoTypes: new stargate_1.AminoTypes((0, stargate_1.createStakingAminoConverters)(testutils_spec_1.wasmd.prefix)),
                    prefix: testutils_spec_1.wasmd.prefix,
                });
                const msgDelegate = {
                    delegatorAddress: testutils_spec_1.alice.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: (0, stargate_1.coin)(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msgDelegate,
                };
                const fee = {
                    amount: (0, stargate_1.coins)(2000, "ustake"),
                    gas: "200000",
                };
                const memo = "Use your tokens wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                (0, stargate_1.assertIsDeliverTxSuccess)(result);
                client.disconnect();
            });
            it("works with wasm MsgStoreCode", async () => {
                (0, testutils_spec_1.pendingWithoutWasmd)();
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, {
                    ...testutils_spec_1.defaultSigningClientOptions,
                    prefix: testutils_spec_1.wasmd.prefix,
                });
                const { data } = (0, testutils_spec_1.getHackatom)();
                const msgStoreCode = {
                    sender: testutils_spec_1.alice.address0,
                    wasmByteCode: pako_1.default.gzip(data),
                    instantiatePermission: undefined,
                };
                const msgAny = {
                    typeUrl: "/cosmwasm.wasm.v1.MsgStoreCode",
                    value: msgStoreCode,
                };
                const fee = {
                    amount: (0, stargate_1.coins)(2000, "ustake"),
                    gas: "1500000",
                };
                const memo = "Use your tokens wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                (0, stargate_1.assertIsDeliverTxSuccess)(result);
                client.disconnect();
            });
            it("works with a custom registry and custom message", async () => {
                (0, testutils_spec_1.pendingWithoutWasmd)();
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
                const customRegistry = new proto_signing_1.Registry();
                const msgDelegateTypeUrl = "/cosmos.staking.v1beta1.MsgDelegate";
                const baseCustomMsgDelegate = {
                    customDelegatorAddress: "",
                    customValidatorAddress: "",
                };
                const CustomMsgDelegate = {
                    // Adapted from autogenerated MsgDelegate implementation
                    encode(message, writer = minimal_1.default.Writer.create()) {
                        var _a, _b;
                        writer.uint32(10).string((_a = message.customDelegatorAddress) !== null && _a !== void 0 ? _a : "");
                        writer.uint32(18).string((_b = message.customValidatorAddress) !== null && _b !== void 0 ? _b : "");
                        if (message.customAmount !== undefined && message.customAmount !== undefined) {
                            coin_1.Coin.encode(message.customAmount, writer.uint32(26).fork()).ldelim();
                        }
                        return writer;
                    },
                    decode() {
                        throw new Error("decode method should not be required");
                    },
                    fromJSON() {
                        throw new Error("fromJSON method should not be required");
                    },
                    fromPartial(object) {
                        const message = { ...baseCustomMsgDelegate };
                        if (object.customDelegatorAddress !== undefined && object.customDelegatorAddress !== null) {
                            message.customDelegatorAddress = object.customDelegatorAddress;
                        }
                        else {
                            message.customDelegatorAddress = "";
                        }
                        if (object.customValidatorAddress !== undefined && object.customValidatorAddress !== null) {
                            message.customValidatorAddress = object.customValidatorAddress;
                        }
                        else {
                            message.customValidatorAddress = "";
                        }
                        if (object.customAmount !== undefined && object.customAmount !== null) {
                            message.customAmount = coin_1.Coin.fromPartial(object.customAmount);
                        }
                        else {
                            message.customAmount = undefined;
                        }
                        return message;
                    },
                    toJSON() {
                        throw new Error("toJSON method should not be required");
                    },
                };
                customRegistry.register(msgDelegateTypeUrl, CustomMsgDelegate);
                const customAminoTypes = new stargate_1.AminoTypes({
                    "/cosmos.staking.v1beta1.MsgDelegate": {
                        aminoType: "cosmos-sdk/MsgDelegate",
                        toAmino: ({ customDelegatorAddress, customValidatorAddress, customAmount, }) => {
                            (0, utils_1.assert)(customDelegatorAddress, "missing customDelegatorAddress");
                            (0, utils_1.assert)(customValidatorAddress, "missing validatorAddress");
                            (0, utils_1.assert)(customAmount, "missing amount");
                            (0, utils_1.assert)(customAmount.amount, "missing amount.amount");
                            (0, utils_1.assert)(customAmount.denom, "missing amount.denom");
                            return {
                                delegator_address: customDelegatorAddress,
                                validator_address: customValidatorAddress,
                                amount: {
                                    amount: customAmount.amount,
                                    denom: customAmount.denom,
                                },
                            };
                        },
                        fromAmino: ({ delegator_address, validator_address, amount, }) => ({
                            customDelegatorAddress: delegator_address,
                            customValidatorAddress: validator_address,
                            customAmount: coin_1.Coin.fromPartial(amount),
                        }),
                    },
                });
                const options = {
                    ...testutils_spec_1.defaultSigningClientOptions,
                    prefix: testutils_spec_1.wasmd.prefix,
                    registry: customRegistry,
                    aminoTypes: customAminoTypes,
                };
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
                const msg = {
                    customDelegatorAddress: testutils_spec_1.alice.address0,
                    customValidatorAddress: testutils_spec_1.validator.validatorAddress,
                    customAmount: (0, stargate_1.coin)(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: (0, stargate_1.coins)(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your power wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                (0, stargate_1.assertIsDeliverTxSuccess)(result);
                client.disconnect();
            });
            it("works with a modifying signer", async () => {
                (0, testutils_spec_1.pendingWithoutWasmd)();
                const wallet = await testutils_spec_1.ModifyingSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, {
                    prefix: testutils_spec_1.wasmd.prefix,
                });
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, {
                    ...testutils_spec_1.defaultSigningClientOptions,
                    aminoTypes: new stargate_1.AminoTypes((0, stargate_1.createStakingAminoConverters)(testutils_spec_1.wasmd.prefix)),
                    prefix: testutils_spec_1.wasmd.prefix,
                });
                const msg = {
                    delegatorAddress: testutils_spec_1.alice.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: (0, stargate_1.coin)(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: (0, stargate_1.coins)(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your power wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                (0, stargate_1.assertIsDeliverTxSuccess)(result);
                await (0, utils_1.sleep)(500);
                const searchResult = await client.getTx(result.transactionHash);
                (0, utils_1.assert)(searchResult, "Must find transaction");
                const tx = (0, proto_signing_1.decodeTxRaw)(searchResult.tx);
                // From ModifyingSecp256k1HdWallet
                expect(tx.body.memo).toEqual("This was modified");
                expect({ ...tx.authInfo.fee.amount[0] }).toEqual((0, stargate_1.coin)(3000, "ucosm"));
                expect(tx.authInfo.fee.gasLimit.toNumber()).toEqual(333333);
                client.disconnect();
            });
        });
    });
    describe("sign", () => {
        describe("direct mode", () => {
            it("works", async () => {
                (0, testutils_spec_1.pendingWithoutWasmd)();
                const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, {
                    ...testutils_spec_1.defaultSigningClientOptions,
                    prefix: testutils_spec_1.wasmd.prefix,
                });
                const msg = tx_2.MsgDelegate.fromPartial({
                    delegatorAddress: testutils_spec_1.alice.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: (0, stargate_1.coin)(1234, "ustake"),
                });
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: (0, stargate_1.coins)(2000, "ucosm"),
                    gas: "180000", // 180k
                };
                const memo = "Use your power wisely";
                const signed = await client.sign(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                (0, stargate_1.assertIsDeliverTxSuccess)(result);
                client.disconnect();
            });
            it("works with a modifying signer", async () => {
                (0, testutils_spec_1.pendingWithoutWasmd)();
                const wallet = await testutils_spec_1.ModifyingDirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, {
                    prefix: testutils_spec_1.wasmd.prefix,
                });
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, {
                    ...testutils_spec_1.defaultSigningClientOptions,
                    prefix: testutils_spec_1.wasmd.prefix,
                });
                const msg = tx_2.MsgDelegate.fromPartial({
                    delegatorAddress: testutils_spec_1.alice.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: (0, stargate_1.coin)(1234, "ustake"),
                });
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: (0, stargate_1.coins)(2000, "ucosm"),
                    gas: "180000", // 180k
                };
                const memo = "Use your power wisely";
                const signed = await client.sign(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                const body = tx_3.TxBody.decode(signed.bodyBytes);
                const authInfo = tx_3.AuthInfo.decode(signed.authInfoBytes);
                // From ModifyingDirectSecp256k1HdWallet
                expect(body.memo).toEqual("This was modified");
                expect({ ...authInfo.fee.amount[0] }).toEqual((0, stargate_1.coin)(3000, "ucosm"));
                expect(authInfo.fee.gasLimit.toNumber()).toEqual(333333);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                (0, stargate_1.assertIsDeliverTxSuccess)(result);
                client.disconnect();
            });
        });
        describe("legacy Amino mode", () => {
            it("works with bank MsgSend", async () => {
                (0, testutils_spec_1.pendingWithoutWasmd)();
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, {
                    ...testutils_spec_1.defaultSigningClientOptions,
                    prefix: testutils_spec_1.wasmd.prefix,
                });
                const msgSend = {
                    fromAddress: testutils_spec_1.alice.address0,
                    toAddress: (0, testutils_spec_1.makeRandomAddress)(),
                    amount: (0, stargate_1.coins)(1234, "ucosm"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.bank.v1beta1.MsgSend",
                    value: msgSend,
                };
                const fee = {
                    amount: (0, stargate_1.coins)(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your tokens wisely";
                const signed = await client.sign(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                (0, stargate_1.assertIsDeliverTxSuccess)(result);
                client.disconnect();
            });
            it("works with staking MsgDelegate", async () => {
                (0, testutils_spec_1.pendingWithoutWasmd)();
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, {
                    ...testutils_spec_1.defaultSigningClientOptions,
                    aminoTypes: new stargate_1.AminoTypes((0, stargate_1.createStakingAminoConverters)(testutils_spec_1.wasmd.prefix)),
                    prefix: testutils_spec_1.wasmd.prefix,
                });
                const msgDelegate = {
                    delegatorAddress: testutils_spec_1.alice.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: (0, stargate_1.coin)(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msgDelegate,
                };
                const fee = {
                    amount: (0, stargate_1.coins)(2000, "ustake"),
                    gas: "200000",
                };
                const memo = "Use your tokens wisely";
                const signed = await client.sign(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                (0, stargate_1.assertIsDeliverTxSuccess)(result);
                client.disconnect();
            });
            it("works with a custom registry and custom message", async () => {
                (0, testutils_spec_1.pendingWithoutWasmd)();
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
                const customRegistry = new proto_signing_1.Registry();
                const msgDelegateTypeUrl = "/cosmos.staking.v1beta1.MsgDelegate";
                const baseCustomMsgDelegate = {
                    customDelegatorAddress: "",
                    customValidatorAddress: "",
                };
                const CustomMsgDelegate = {
                    // Adapted from autogenerated MsgDelegate implementation
                    encode(message, writer = minimal_1.default.Writer.create()) {
                        var _a, _b;
                        writer.uint32(10).string((_a = message.customDelegatorAddress) !== null && _a !== void 0 ? _a : "");
                        writer.uint32(18).string((_b = message.customValidatorAddress) !== null && _b !== void 0 ? _b : "");
                        if (message.customAmount !== undefined && message.customAmount !== undefined) {
                            coin_1.Coin.encode(message.customAmount, writer.uint32(26).fork()).ldelim();
                        }
                        return writer;
                    },
                    decode() {
                        throw new Error("decode method should not be required");
                    },
                    fromJSON() {
                        throw new Error("fromJSON method should not be required");
                    },
                    fromPartial(object) {
                        const message = { ...baseCustomMsgDelegate };
                        if (object.customDelegatorAddress !== undefined && object.customDelegatorAddress !== null) {
                            message.customDelegatorAddress = object.customDelegatorAddress;
                        }
                        else {
                            message.customDelegatorAddress = "";
                        }
                        if (object.customValidatorAddress !== undefined && object.customValidatorAddress !== null) {
                            message.customValidatorAddress = object.customValidatorAddress;
                        }
                        else {
                            message.customValidatorAddress = "";
                        }
                        if (object.customAmount !== undefined && object.customAmount !== null) {
                            message.customAmount = coin_1.Coin.fromPartial(object.customAmount);
                        }
                        else {
                            message.customAmount = undefined;
                        }
                        return message;
                    },
                    toJSON() {
                        throw new Error("toJSON method should not be required");
                    },
                };
                customRegistry.register(msgDelegateTypeUrl, CustomMsgDelegate);
                const customAminoTypes = new stargate_1.AminoTypes({
                    "/cosmos.staking.v1beta1.MsgDelegate": {
                        aminoType: "cosmos-sdk/MsgDelegate",
                        toAmino: ({ customDelegatorAddress, customValidatorAddress, customAmount, }) => {
                            (0, utils_1.assert)(customDelegatorAddress, "missing customDelegatorAddress");
                            (0, utils_1.assert)(customValidatorAddress, "missing validatorAddress");
                            (0, utils_1.assert)(customAmount, "missing amount");
                            return {
                                delegator_address: customDelegatorAddress,
                                validator_address: customValidatorAddress,
                                amount: {
                                    amount: customAmount.amount,
                                    denom: customAmount.denom,
                                },
                            };
                        },
                        fromAmino: ({ delegator_address, validator_address, amount, }) => ({
                            customDelegatorAddress: delegator_address,
                            customValidatorAddress: validator_address,
                            customAmount: coin_1.Coin.fromPartial(amount),
                        }),
                    },
                });
                const options = {
                    ...testutils_spec_1.defaultSigningClientOptions,
                    registry: customRegistry,
                    aminoTypes: customAminoTypes,
                };
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
                const msg = {
                    customDelegatorAddress: testutils_spec_1.alice.address0,
                    customValidatorAddress: testutils_spec_1.validator.validatorAddress,
                    customAmount: (0, stargate_1.coin)(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: (0, stargate_1.coins)(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your power wisely";
                const signed = await client.sign(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                (0, stargate_1.assertIsDeliverTxSuccess)(result);
                client.disconnect();
            });
            it("works with a modifying signer", async () => {
                (0, testutils_spec_1.pendingWithoutWasmd)();
                const wallet = await testutils_spec_1.ModifyingSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, {
                    prefix: testutils_spec_1.wasmd.prefix,
                });
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, {
                    ...testutils_spec_1.defaultSigningClientOptions,
                    aminoTypes: new stargate_1.AminoTypes((0, stargate_1.createStakingAminoConverters)(testutils_spec_1.wasmd.prefix)),
                    prefix: testutils_spec_1.wasmd.prefix,
                });
                const msg = {
                    delegatorAddress: testutils_spec_1.alice.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: (0, stargate_1.coin)(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: (0, stargate_1.coins)(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your power wisely";
                const signed = await client.sign(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                const body = tx_3.TxBody.decode(signed.bodyBytes);
                const authInfo = tx_3.AuthInfo.decode(signed.authInfoBytes);
                // From ModifyingSecp256k1HdWallet
                expect(body.memo).toEqual("This was modified");
                expect({ ...authInfo.fee.amount[0] }).toEqual((0, stargate_1.coin)(3000, "ucosm"));
                expect(authInfo.fee.gasLimit.toNumber()).toEqual(333333);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                (0, stargate_1.assertIsDeliverTxSuccess)(result);
                client.disconnect();
            });
        });
    });
});
//# sourceMappingURL=signingcosmwasmclient.spec.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/naming-convention */
const jsonrpc_1 = require("../jsonrpc");
const testutil_spec_1 = require("../testutil.spec");
const httpclient_1 = require("./httpclient");
function pendingWithoutTendermint() {
    if (!process.env.TENDERMINT_ENABLED) {
        pending("Set TENDERMINT_ENABLED to enable Tendermint RPC tests");
    }
}
function pendingWithoutHttpServer() {
    if (!process.env.HTTPSERVER_ENABLED) {
        pending("Set HTTPSERVER_ENABLED to enable HTTP tests");
    }
}
const tendermintUrl = testutil_spec_1.defaultInstance.url;
const echoUrl = "http://localhost:5555/echo_headers";
describe("http", () => {
    it("can send a health request", async () => {
        pendingWithoutTendermint();
        const response = await (0, httpclient_1.http)("POST", `http://${tendermintUrl}`, undefined, (0, jsonrpc_1.createJsonRpcRequest)("health"));
        expect(response).toEqual(jasmine.objectContaining({ jsonrpc: "2.0" }));
    });
    it("errors for non-open port", async () => {
        await expectAsync((0, httpclient_1.http)("POST", `http://localhost:56745`, undefined, (0, jsonrpc_1.createJsonRpcRequest)("health"))).toBeRejectedWithError(/(ECONNREFUSED|Failed to fetch)/i);
    });
    it("can send custom headers", async () => {
        pendingWithoutHttpServer();
        // Without custom headers
        const response1 = await (0, httpclient_1.http)("POST", echoUrl, undefined, (0, jsonrpc_1.createJsonRpcRequest)("health"));
        expect(response1).toEqual({
            request_headers: jasmine.objectContaining({
                // Basic headers from http client
                Accept: jasmine.any(String),
                "Content-Length": jasmine.any(String),
                "Content-Type": "application/json",
                Host: jasmine.any(String),
                "User-Agent": jasmine.any(String),
            }),
        });
        // With custom headers
        const response2 = await (0, httpclient_1.http)("POST", echoUrl, { foo: "bar123", Authorization: "Basic Z3Vlc3Q6bm9QYXNzMTIz" }, (0, jsonrpc_1.createJsonRpcRequest)("health"));
        expect(response2).toEqual({
            request_headers: jasmine.objectContaining({
                // Basic headers from http client
                "Content-Length": jasmine.any(String),
                "Content-Type": "application/json",
                Host: jasmine.any(String),
                "User-Agent": jasmine.any(String),
                // Custom headers
                foo: "bar123",
                Authorization: "Basic Z3Vlc3Q6bm9QYXNzMTIz",
            }),
        });
    });
});
describe("HttpClient", () => {
    it("can make a simple call", async () => {
        pendingWithoutTendermint();
        const client = new httpclient_1.HttpClient(tendermintUrl);
        const healthResponse = await client.execute((0, jsonrpc_1.createJsonRpcRequest)("health"));
        expect(healthResponse.result).toEqual({});
        const statusResponse = await client.execute((0, jsonrpc_1.createJsonRpcRequest)("status"));
        expect(statusResponse.result).toBeTruthy();
        expect(statusResponse.result.node_info).toBeTruthy();
        await client
            .execute((0, jsonrpc_1.createJsonRpcRequest)("no-such-method"))
            .then(() => fail("must not resolve"))
            .catch((error) => expect(error).toBeTruthy());
        client.disconnect();
    });
});
//# sourceMappingURL=httpclient.spec.js.map
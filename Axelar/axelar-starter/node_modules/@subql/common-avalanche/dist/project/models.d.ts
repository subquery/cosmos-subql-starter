import { RegisteredTypes, RegistryTypes, OverrideModuleType, OverrideBundleType } from '@polkadot/types/types';
import { AvalancheLogFilter, AvalancheHandlerKind, SubqlCustomHandler, SubqlMapping, SubqlHandler, SubqlRuntimeHandler, SubqlRuntimeDatasource, AvalancheDatasourceKind, SubqlCustomDatasource, FileReference, CustomDataSourceAsset, AvalancheBlockFilter, SubqlBlockHandler, SubqlEventHandler, SubqlCallHandler, AvalancheTransactionFilter } from '@subql/types-avalanche';
export declare class BlockFilter implements AvalancheBlockFilter {
    modulo?: number;
}
export declare class LogFilter implements AvalancheLogFilter {
    topics?: string[];
    address?: string;
}
export declare class ChainTypes implements RegisteredTypes {
    types?: RegistryTypes;
    typesAlias?: Record<string, OverrideModuleType>;
    typesBundle?: OverrideBundleType;
    typesChain?: Record<string, RegistryTypes>;
    typesSpec?: Record<string, RegistryTypes>;
}
export declare class TransactionFilter implements AvalancheTransactionFilter {
    from?: string;
    to?: string;
    function?: string;
}
export declare class BlockHandler implements SubqlBlockHandler {
    filter?: BlockFilter;
    kind: AvalancheHandlerKind.Block;
    handler: string;
}
export declare class CallHandler implements SubqlCallHandler {
    filter?: TransactionFilter;
    kind: AvalancheHandlerKind.Call;
    handler: string;
}
export declare class EventHandler implements SubqlEventHandler {
    filter?: LogFilter;
    kind: AvalancheHandlerKind.Event;
    handler: string;
}
export declare class CustomHandler implements SubqlCustomHandler {
    kind: string;
    handler: string;
    filter?: Record<string, unknown>;
}
export declare class AvalancheMapping implements SubqlMapping {
    handlers: SubqlHandler[];
    file: string;
}
export declare class CustomMapping implements SubqlMapping<SubqlCustomHandler> {
    handlers: CustomHandler[];
    file: string;
}
export declare class RuntimeDataSourceBase<M extends SubqlMapping<SubqlRuntimeHandler>> implements SubqlRuntimeDatasource<M> {
    kind: AvalancheDatasourceKind.Runtime;
    mapping: M;
    startBlock?: number;
    assets?: Map<string, FileReference>;
    options?: any;
}
export declare class FileReferenceImpl implements FileReference {
    file: string;
}
export declare class CustomDataSourceBase<K extends string, M extends SubqlMapping = SubqlMapping<SubqlCustomHandler>> implements SubqlCustomDatasource<K, M> {
    kind: K;
    mapping: M;
    startBlock?: number;
    assets: Map<string, CustomDataSourceAsset>;
    processor: FileReference;
}

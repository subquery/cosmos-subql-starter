"use strict";
// Copyright 2020-2022 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@subql/common");
const rules_1 = require("./rules");
const validator_1 = require("./validator");
describe('Validate project below manifest spec 1.0.0', () => {
    let v;
    const url = 'https://github.com/subquery/tutorials-block-timestamp';
    beforeAll(async () => {
        v = await validator_1.Validator.create(url, null, common_1.NETWORK_FAMILY.substrate);
        v.addRule(...rules_1.commonRules);
    });
    it('should throw error if manifest is below 1.0.0 and network is not provided', async () => {
        const v1 = await validator_1.Validator.create(url);
        v1.addRule(...rules_1.commonRules);
        await expect(v1.getValidateReports()).rejects.toThrow(/Can not identify project network under spec version 1.0.0/);
    });
    it('should validate get reports', async () => {
        const result = await v.getValidateReports();
        expect(result.filter((r) => r.valid).length).toBe(result.length);
    });
    it('should return validate result', async () => {
        const result = await v.validate();
        expect(result).toBeTruthy();
    });
});
describe('Validate project with manifest spec 1.0.0, auto identify network', () => {
    it('should validate IPFS deployment', async () => {
        const cid = 'ipfs://QmVX1aaJRL9f5Vgjr8VJ9MWAcFHzAya9omnQ534JYCigCQ';
        const v = await validator_1.Validator.create(cid, { ipfs: common_1.IPFS_NODE_ENDPOINT });
        v.addRule(...rules_1.deploymentRules);
        const result = await v.getValidateReports();
        expect(result.filter((r) => r.valid).length).toBe(result.length);
    });
    it('should validate get reports', async () => {
        const url = 'https://github.com/subquery/tutorials-frontier-evm-starter';
        const v = await validator_1.Validator.create(url);
        v.addRule(...rules_1.commonRules);
        const result = await v.getValidateReports();
        expect(result.filter((r) => r.valid).length).toBe(result.length);
    });
});
//# sourceMappingURL=validator.spec.js.map
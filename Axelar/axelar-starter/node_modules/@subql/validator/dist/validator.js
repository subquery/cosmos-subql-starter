"use strict";
// Copyright 2020-2022 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.Validator = void 0;
const common_1 = require("@subql/common");
const common_algorand_1 = require("@subql/common-algorand");
const common_avalanche_1 = require("@subql/common-avalanche");
const common_cosmos_1 = require("@subql/common-cosmos");
const common_ethereum_1 = require("@subql/common-ethereum");
const common_flare_1 = require("@subql/common-flare");
const common_substrate_1 = require("@subql/common-substrate");
const common_terra_1 = require("@subql/common-terra");
const rules_1 = require("./rules");
class Validator {
    constructor(reader, location, networkFamily) {
        this.reader = reader;
        this.location = location;
        this.networkFamily = networkFamily;
        this.rules = [];
    }
    static async create(location, opts, networkFamily) {
        return new Validator(await common_1.ReaderFactory.create(location, opts), location, networkFamily);
    }
    addRule(...rules) {
        this.rules.push(...rules);
    }
    async getValidateReports() {
        var _a;
        const reports = [];
        const [pkg, rawSchema] = await Promise.all([this.reader.getPkg(), this.reader.getProjectSchema()]);
        if (!rawSchema) {
            throw new Error('Not a valid SubQuery project, project.yaml is missing');
        }
        reports.push({
            name: 'project-yaml-file',
            description: 'A valid `project.yaml` file must exist in the root directory of the project',
            valid: !!rawSchema,
            skipped: false,
        });
        let schema;
        const networkFamily = (_a = this.networkFamily) !== null && _a !== void 0 ? _a : (0, common_1.getProjectNetwork)(rawSchema);
        switch (networkFamily) {
            case common_1.NETWORK_FAMILY.substrate:
                schema = (0, common_substrate_1.parseSubstrateProjectManifest)(rawSchema);
                if (schema.isV0_0_1) {
                    reports.push({
                        name: 'package-json-file',
                        description: 'A valid `package.json` file must exist in the root directory of the project',
                        valid: !!pkg,
                        skipped: false,
                    });
                }
                break;
            case common_1.NETWORK_FAMILY.terra:
                schema = (0, common_terra_1.parseTerraProjectManifest)(rawSchema);
                break;
            case common_1.NETWORK_FAMILY.avalanche:
                schema = (0, common_avalanche_1.parseSubstrateProjectManifest)(rawSchema);
                break;
            case common_1.NETWORK_FAMILY.cosmos:
                schema = (0, common_cosmos_1.parseCosmosProjectManifest)(rawSchema);
                break;
            case common_1.NETWORK_FAMILY.algorand:
                schema = (0, common_algorand_1.parseAlgorandProjectManifest)(rawSchema);
                break;
            case common_1.NETWORK_FAMILY.ethereum:
                schema = (0, common_ethereum_1.parseEthereumProjectManifest)(rawSchema);
                break;
            case common_1.NETWORK_FAMILY.flare:
                schema = (0, common_flare_1.parseEthereumProjectManifest)(rawSchema);
                break;
            default:
                console.error(`Load project failed, please check the manifest file.`);
                break;
        }
        const ctx = {
            data: {
                projectPath: this.location,
                pkg,
                schema,
            },
            logger: console,
            reader: this.reader,
        };
        for (const r of this.rules) {
            const report = {
                name: r.name,
                description: r.description,
                valid: false,
                skipped: false,
            };
            if ((!pkg && r.type === rules_1.RuleType.PackageJSON) || (!schema && r.type === rules_1.RuleType.Schema)) {
                report.skipped = true;
            }
            else {
                report.valid = await r.validate(ctx);
            }
            reports.push(report);
        }
        return reports;
    }
    async validate() {
        const reports = await this.getValidateReports();
        return !reports.some((r) => !r.valid);
    }
}
exports.Validator = Validator;
//# sourceMappingURL=validator.js.map
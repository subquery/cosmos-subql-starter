{"version":3,"file":"project.js","sourceRoot":"","sources":["../src/project.ts"],"names":[],"mappings":";AAAA,gEAAgE;AAChE,sCAAsC;;;AAMtC,IAAY,uBAEX;AAFD,WAAY,uBAAuB;IACjC,wDAA6B,CAAA;AAC/B,CAAC,EAFW,uBAAuB,GAAvB,+BAAuB,KAAvB,+BAAuB,QAElC;AAED,IAAY,oBAIX;AAJD,WAAY,oBAAoB;IAC9B,wDAAgC,CAAA;IAChC,sDAA8B,CAAA;IAC9B,wDAAgC,CAAA;AAClC,CAAC,EAJW,oBAAoB,GAApB,4BAAoB,KAApB,4BAAoB,QAI/B","sourcesContent":["// Copyright 2020-2022 OnFinality Limited authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport {ApiPromise} from '@polkadot/api';\nimport {AnyTuple, RegistryTypes} from '@polkadot/types/types';\nimport {SubstrateBlock, SubstrateEvent, SubstrateExtrinsic} from './interfaces';\n\nexport enum SubstrateDatasourceKind {\n  Runtime = 'substrate/Runtime',\n}\n\nexport enum SubstrateHandlerKind {\n  Block = 'substrate/BlockHandler',\n  Call = 'substrate/CallHandler',\n  Event = 'substrate/EventHandler',\n}\n\nexport type RuntimeHandlerInputMap<T extends AnyTuple = AnyTuple> = {\n  [SubstrateHandlerKind.Block]: SubstrateBlock;\n  [SubstrateHandlerKind.Event]: SubstrateEvent<T>;\n  [SubstrateHandlerKind.Call]: SubstrateExtrinsic<T>;\n};\n\ntype RuntimeFilterMap = {\n  [SubstrateHandlerKind.Block]: SubstrateNetworkFilter;\n  [SubstrateHandlerKind.Event]: SubstrateEventFilter;\n  [SubstrateHandlerKind.Call]: SubstrateCallFilter;\n};\n\nexport interface ProjectManifest {\n  specVersion: string;\n  description: string;\n  repository: string;\n\n  schema: string;\n\n  network: {\n    endpoint: string;\n    customTypes?: RegistryTypes;\n  };\n\n  dataSources: SubstrateDatasource[];\n}\n\n// [startSpecVersion?, endSpecVersion?] closed range\nexport type SpecVersionRange = [number, number];\n\ninterface SubstrateBaseHandlerFilter {\n  specVersion?: SpecVersionRange;\n}\n\nexport interface SubstrateBlockFilter extends SubstrateBaseHandlerFilter {\n  modulo?: number;\n  timestamp?: string;\n}\n\nexport interface SubstrateEventFilter extends SubstrateBaseHandlerFilter {\n  module?: string;\n  method?: string;\n}\n\nexport interface SubstrateCallFilter extends SubstrateEventFilter {\n  success?: boolean;\n}\n\nexport type SubstrateBlockHandler = SubstrateCustomHandler<SubstrateHandlerKind.Block, SubstrateBlockFilter>;\nexport type SubstrateCallHandler = SubstrateCustomHandler<SubstrateHandlerKind.Call, SubstrateCallFilter>;\nexport type SubstrateEventHandler = SubstrateCustomHandler<SubstrateHandlerKind.Event, SubstrateEventFilter>;\n\nexport interface SubstrateCustomHandler<K extends string = string, F = Record<string, unknown>> {\n  handler: string;\n  kind: K;\n  filter?: F;\n}\n\nexport type SubstrateRuntimeHandler = SubstrateBlockHandler | SubstrateCallHandler | SubstrateEventHandler;\nexport type SubstrateHandler = SubstrateRuntimeHandler | SubstrateCustomHandler<string, unknown>;\nexport type SubstrateRuntimeHandlerFilter = SubstrateBlockFilter | SubstrateCallFilter | SubstrateEventFilter;\n\nexport interface SubstrateMapping<T extends SubstrateHandler = SubstrateHandler> extends FileReference {\n  handlers: T[];\n}\n\ninterface ISubstrateDatasource<M extends SubstrateMapping, F extends SubstrateNetworkFilter = SubstrateNetworkFilter> {\n  name?: string;\n  kind: string;\n  filter?: F;\n  startBlock?: number;\n  mapping: M;\n}\n\nexport interface SubstrateRuntimeDatasource<\n  M extends SubstrateMapping<SubstrateRuntimeHandler> = SubstrateMapping<SubstrateRuntimeHandler>\n> extends ISubstrateDatasource<M> {\n  kind: SubstrateDatasourceKind.Runtime;\n}\n\nexport interface SubstrateNetworkFilter {\n  specName?: string;\n}\n\nexport type SubstrateDatasource = SubstrateRuntimeDatasource | SubstrateCustomDatasource; // | SubstrateBuiltinDataSource;\n\nexport interface FileReference {\n  file: string;\n}\n\nexport type CustomDataSourceAsset = FileReference;\n\nexport type Processor<O = any> = FileReference & {options?: O};\n\nexport interface SubstrateCustomDatasource<\n  K extends string = string,\n  T extends SubstrateNetworkFilter = SubstrateNetworkFilter,\n  M extends SubstrateMapping = SubstrateMapping<SubstrateCustomHandler>,\n  O = any\n> extends ISubstrateDatasource<M, T> {\n  kind: K;\n  assets: Map<string, CustomDataSourceAsset>;\n  processor: Processor<O>;\n}\n\n//export type SubstrateBuiltinDataSource = ISubstrateDatasource;\n\nexport interface HandlerInputTransformer_0_0_0<\n  T extends SubstrateHandlerKind,\n  E,\n  IT extends AnyTuple,\n  DS extends SubstrateCustomDatasource = SubstrateCustomDatasource\n> {\n  (input: RuntimeHandlerInputMap<IT>[T], ds: DS, api: ApiPromise, assets?: Record<string, string>): Promise<E>; //  | SubstrateBuiltinDataSource\n}\n\nexport interface HandlerInputTransformer_1_0_0<\n  T extends SubstrateHandlerKind,\n  F,\n  E,\n  IT extends AnyTuple,\n  DS extends SubstrateCustomDatasource = SubstrateCustomDatasource\n> {\n  (params: {\n    input: RuntimeHandlerInputMap<IT>[T];\n    ds: DS;\n    filter?: F;\n    api: ApiPromise;\n    assets?: Record<string, string>;\n  }): Promise<E[]>; //  | SubstrateBuiltinDataSource\n}\n\ntype SecondLayerHandlerProcessorArray<\n  K extends string,\n  F extends SubstrateNetworkFilter,\n  T,\n  IT extends AnyTuple = AnyTuple,\n  DS extends SubstrateCustomDatasource<K, F> = SubstrateCustomDatasource<K, F>\n> =\n  | SecondLayerHandlerProcessor<SubstrateHandlerKind.Block, F, T, IT, DS>\n  | SecondLayerHandlerProcessor<SubstrateHandlerKind.Call, F, T, IT, DS>\n  | SecondLayerHandlerProcessor<SubstrateHandlerKind.Event, F, T, IT, DS>;\n\nexport interface SubstrateDatasourceProcessor<\n  K extends string,\n  F extends SubstrateNetworkFilter,\n  DS extends SubstrateCustomDatasource<K, F> = SubstrateCustomDatasource<K, F>,\n  P extends Record<string, SecondLayerHandlerProcessorArray<K, F, any, any, DS>> = Record<\n    string,\n    SecondLayerHandlerProcessorArray<K, F, any, any, DS>\n  >\n> {\n  kind: K;\n  validate(ds: DS, assets: Record<string, string>): void;\n  dsFilterProcessor(ds: DS, api: ApiPromise): boolean;\n  handlerProcessors: P;\n}\n\nexport interface DictionaryQueryCondition {\n  field: string;\n  value: string;\n  matcher?: string; // defaults to \"equalTo\", use \"contains\" for JSON\n}\n\nexport interface DictionaryQueryEntry {\n  entity: string;\n  conditions: DictionaryQueryCondition[];\n}\n\ninterface SecondLayerHandlerProcessorBase<\n  K extends SubstrateHandlerKind,\n  F,\n  DS extends SubstrateCustomDatasource = SubstrateCustomDatasource\n> {\n  baseHandlerKind: K;\n  baseFilter: RuntimeFilterMap[K] | RuntimeFilterMap[K][];\n  filterValidator: (filter?: F) => void;\n  dictionaryQuery?: (filter: F, ds: DS) => DictionaryQueryEntry | undefined;\n}\n\n// only allow one custom handler for each baseHandler kind\nexport interface SecondLayerHandlerProcessor_0_0_0<\n  K extends SubstrateHandlerKind,\n  F,\n  E,\n  IT extends AnyTuple = AnyTuple,\n  DS extends SubstrateCustomDatasource = SubstrateCustomDatasource\n> extends SecondLayerHandlerProcessorBase<K, F, DS> {\n  specVersion: undefined;\n  transformer: HandlerInputTransformer_0_0_0<K, E, IT, DS>;\n  filterProcessor: (filter: F | undefined, input: RuntimeHandlerInputMap<IT>[K], ds: DS) => boolean;\n}\n\nexport interface SecondLayerHandlerProcessor_1_0_0<\n  K extends SubstrateHandlerKind,\n  F,\n  E,\n  IT extends AnyTuple = AnyTuple,\n  DS extends SubstrateCustomDatasource = SubstrateCustomDatasource\n> extends SecondLayerHandlerProcessorBase<K, F, DS> {\n  specVersion: '1.0.0';\n  transformer: HandlerInputTransformer_1_0_0<K, F, E, IT, DS>;\n  filterProcessor: (params: {filter: F | undefined; input: RuntimeHandlerInputMap<IT>[K]; ds: DS}) => boolean;\n}\n\nexport type SecondLayerHandlerProcessor<\n  K extends SubstrateHandlerKind,\n  F,\n  E,\n  IT extends AnyTuple = AnyTuple,\n  DS extends SubstrateCustomDatasource = SubstrateCustomDatasource\n> = SecondLayerHandlerProcessor_0_0_0<K, F, E, IT, DS> | SecondLayerHandlerProcessor_1_0_0<K, F, E, IT, DS>;\n"]}
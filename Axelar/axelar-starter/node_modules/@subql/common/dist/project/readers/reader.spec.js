"use strict";
// Copyright 2020-2022 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const github_reader_1 = require("./github-reader");
const ipfs_reader_1 = require("./ipfs-reader");
const local_reader_1 = require("./local-reader");
const reader_1 = require("./reader");
const tarPath = path_1.default.join(__dirname, '/../../../test/mockedSubqueryProject.tgz');
describe('ReaderFactory', () => {
    it('should return the Github Reader', async () => {
        const url = 'https://github.com/subquery/subql-starter';
        const reader = await reader_1.ReaderFactory.create(url);
        expect(reader instanceof github_reader_1.GithubReader).toBeTruthy();
    });
    it('should return the Local Reader', async () => {
        const loc = path_1.default.join(__dirname, '../../../fixtures');
        const reader = await reader_1.ReaderFactory.create(loc);
        expect(reader instanceof local_reader_1.LocalReader).toBeTruthy();
    });
    it('should return the IPFS Reader for a CID v0', async () => {
        const loc = 'ipfs://QmYyCCSaHLpPvZmex5ExHGdW7mavKYeiixVEyvNGwD1LLw';
        const reader = await reader_1.ReaderFactory.create(loc, {});
        expect(reader instanceof ipfs_reader_1.IPFSReader).toBeTruthy();
    });
    it('should return the IPFS Reader for a CID v1', async () => {
        const loc = 'ipfs://bafybeie56fq7db5adfyt3afqwhje6pq2m77gn5ik6pg75bioger6kzjn6a';
        const reader = await reader_1.ReaderFactory.create(loc, {});
        expect(reader instanceof ipfs_reader_1.IPFSReader).toBeTruthy();
    });
    it.skip('should support archive files', async () => {
        const reader = await reader_1.ReaderFactory.create(tarPath);
        const finalPath = reader.root;
        expect(fs_1.default.existsSync(finalPath)).toBeTruthy();
    });
    it('throw error if getProjectRootAndManifest path not exist', async () => {
        await expect(() => reader_1.ReaderFactory.create('path/not/exist')).rejects.toThrow(/unknown location/);
    });
    it('throw error if ipfs path is not valid', async () => {
        await expect(() => reader_1.ReaderFactory.create('ipfs://notValid', {})).rejects.toThrow(/IPFS project path CID is not valid/);
    });
});
//# sourceMappingURL=reader.spec.js.map
{"version":3,"file":"project.js","sourceRoot":"","sources":["../src/project.ts"],"names":[],"mappings":";AAAA,gEAAgE;AAChE,sCAAsC;;;AAatC,IAAY,wBAGX;AAHD,WAAY,wBAAwB;IAClC,qDAAyB,CAAA;IACzB,mDAAuB,CAAA;AACzB,CAAC,EAHW,wBAAwB,GAAxB,gCAAwB,KAAxB,gCAAwB,QAGnC;AAED,IAAY,qBAKX;AALD,WAAY,qBAAqB;IAC/B,qDAA4B,CAAA;IAC5B,iEAAwC,CAAA;IACxC,yDAAgC,CAAA;IAChC,qDAA4B,CAAA;AAC9B,CAAC,EALW,qBAAqB,GAArB,6BAAqB,KAArB,6BAAqB,QAKhC","sourcesContent":["// Copyright 2020-2022 OnFinality Limited authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport {LCDClient} from '@terra-money/terra.js';\nimport {TerraBlock, TerraTransaction, TerraMessage, TerraEvent} from './interfaces';\n\nexport interface FileReference {\n  file: string;\n}\n\nexport type CustomDataSourceAsset = FileReference;\n\nexport type Processor<O = any> = FileReference & {options?: O};\n\nexport enum SubqlTerraDatasourceKind {\n  Runtime = 'terra/Runtime',\n  Custom = 'terra/Custom',\n}\n\nexport enum SubqlTerraHandlerKind {\n  Block = 'terra/BlockHandler',\n  Transaction = 'terra/TransactionHandler',\n  Message = 'terra/MessageHandler',\n  Event = 'terra/EventHandler',\n}\n\nexport type TerraRuntimeHandlerInputMap = {\n  [SubqlTerraHandlerKind.Block]: TerraBlock;\n  [SubqlTerraHandlerKind.Transaction]: TerraTransaction;\n  [SubqlTerraHandlerKind.Message]: TerraMessage;\n  [SubqlTerraHandlerKind.Event]: TerraEvent;\n};\n\ntype TerraRuntimeFilterMap = {\n  [SubqlTerraHandlerKind.Block]: {};\n  [SubqlTerraHandlerKind.Transaction]: {};\n  [SubqlTerraHandlerKind.Message]: SubqlTerraMessageFilter;\n  [SubqlTerraHandlerKind.Event]: SubqlTerraEventFilter;\n};\n\nexport interface TerraProjectManifest {\n  specVersion: string;\n  description: string;\n  repository: string;\n\n  schema: {\n    file: string;\n  };\n\n  network: TerraNetwork;\n\n  dataSources: SubqlTerraDatasource[];\n}\n\nexport interface TerraNetwork {\n  genesisHash: string;\n  endpoint: string;\n  chainId: string;\n}\n\nexport interface SubqlTerraMessageFilter {\n  type: string;\n  contractCall?: string;\n  values?: {\n    [key: string]: string;\n  };\n}\n\nexport interface SubqlTerraEventFilter {\n  type: string;\n  messageFilter?: SubqlTerraMessageFilter;\n}\n\nexport type SubqlTerraHandlerFilter = SubqlTerraEventFilter | SubqlTerraMessageFilter;\n\nexport interface SubqlTerraBlockHandler {\n  handler: string;\n  kind: SubqlTerraHandlerKind.Block;\n}\n\nexport interface SubqlTerraTransactionHandler {\n  handler: string;\n  kind: SubqlTerraHandlerKind.Transaction;\n}\n\nexport interface SubqlTerraMessageHandler {\n  handler: string;\n  kind: SubqlTerraHandlerKind.Message;\n  filter?: SubqlTerraMessageFilter;\n}\n\nexport interface SubqlTerraEventHandler {\n  handler: string;\n  kind: SubqlTerraHandlerKind.Event;\n  filter?: SubqlTerraEventFilter;\n}\n\nexport interface SubqlTerraCustomHandler<K extends string = string, F = Record<string, unknown>> {\n  handler: string;\n  kind: K;\n  filter?: F;\n}\n\nexport type SubqlTerraRuntimeHandler =\n  | SubqlTerraBlockHandler\n  | SubqlTerraTransactionHandler\n  | SubqlTerraMessageHandler\n  | SubqlTerraEventHandler;\n\nexport type SubqlTerraHandler = SubqlTerraRuntimeHandler | SubqlTerraCustomHandler;\n\nexport interface SubqlTerraMapping<T extends SubqlTerraHandler = SubqlTerraHandler> {\n  file: string;\n  handlers: T[];\n}\n\ninterface ISubqlTerraDatasource<M extends SubqlTerraMapping> {\n  name?: string;\n  kind: string;\n  startBlock?: number;\n  mapping: M;\n}\n\nexport interface SubqlTerraRuntimeDatasource<\n  M extends SubqlTerraMapping<SubqlTerraRuntimeHandler> = SubqlTerraMapping<SubqlTerraRuntimeHandler>\n> extends ISubqlTerraDatasource<M> {\n  kind: SubqlTerraDatasourceKind.Runtime;\n}\n\nexport type SubqlTerraDatasource = SubqlTerraRuntimeDatasource | SubqlTerraCustomDatasource;\n\nexport type CustomTerraDataSourceAsset = FileReference;\n\nexport interface SubqlTerraCustomDatasource<\n  K extends string = string,\n  M extends SubqlTerraMapping = SubqlTerraMapping<SubqlTerraCustomHandler>,\n  O = any\n> extends ISubqlTerraDatasource<M> {\n  kind: K;\n  assets: Map<string, CustomTerraDataSourceAsset>;\n  processor?: Processor<O>;\n}\n\nexport interface TerraHandlerInputTransformer<\n  T extends SubqlTerraHandlerKind,\n  U,\n  DS extends SubqlTerraCustomDatasource = SubqlTerraCustomDatasource\n> {\n  (original: TerraRuntimeHandlerInputMap[T], ds: DS, api: LCDClient, assets: Record<string, string>): Promise<U>; //  | SubqlBuiltinDataSource\n}\n\nexport interface SubqlTerraDatasourceProcessor<\n  K extends string,\n  DS extends SubqlTerraCustomDatasource<K> = SubqlTerraCustomDatasource<K>\n> {\n  kind: K;\n  validate(ds: DS, assets: Record<string, string>): void;\n  dsFilterProcessor(ds: DS, api: LCDClient): boolean;\n  handlerProcessors: {\n    [kind: string]: SecondLayerTerraHandlerProcessor<SubqlTerraHandlerKind, unknown, unknown, DS>;\n  };\n}\n\nexport interface DictionaryQueryCondition {\n  field: string;\n  value: string | Record<string, string> | Array<Record<string, string>>;\n  matcher?: string; // defaults to \"equalTo\", use \"contains\" for JSON\n}\n\nexport interface DictionaryQueryEntry {\n  entity: string;\n  conditions: DictionaryQueryCondition[];\n}\n\nexport interface SecondLayerTerraHandlerProcessor<\n  K extends SubqlTerraHandlerKind,\n  F,\n  E,\n  DS extends SubqlTerraCustomDatasource = SubqlTerraCustomDatasource\n> {\n  baseHandlerKind: K;\n  baseFilter: TerraRuntimeFilterMap[K] | TerraRuntimeFilterMap[K][];\n  transformer: TerraHandlerInputTransformer<K, E, DS>;\n  filterProcessor: (filter: F | undefined, input: TerraRuntimeHandlerInputMap[K], ds: DS) => boolean;\n  filterValidator: (filter: F) => void;\n  dictionaryQuery: (filter: F, ds: DS) => DictionaryQueryEntry;\n}\n"]}
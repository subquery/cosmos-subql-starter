"use strict";
// Copyright 2020-2022 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.createChainTypes = exports.migrate = exports.prepare = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const common_substrate_1 = require("@subql/common-substrate");
const common_terra_1 = require("@subql/common-terra");
const class_transformer_1 = require("class-transformer");
const cli_ux_1 = require("cli-ux");
const inquirer_1 = tslib_1.__importDefault(require("inquirer"));
const js_yaml_1 = tslib_1.__importDefault(require("js-yaml"));
const jsonrpc_1 = require("../jsonrpc");
const MANIFEST_PATH = 'project.yaml';
const MANIFEST_OLD = `project_old.yaml`;
const MANIFEST_V_1_0_0 = `project_1_0_0.yaml`;
const SUBSTRATE_NODE_NAME = '@subql/node';
const TERRA_NODE_NAME = '@subql/node-terra';
const DEFAULT_QUERY_NAME = '@subql/query';
// eslint-disable-next-line complexity
async function prepare(location, manifest) {
    const packageData = await fs_1.default.promises.readFile(`${location}/package.json`, 'utf8');
    const jsonProjectData = JSON.parse(packageData);
    let chainTypesRelativePath;
    const project = { runner: { node: {}, query: {} } };
    const projectNetwork = manifest instanceof common_substrate_1.SubstrateProjectManifestVersioned && manifest.isV0_0_1
        ? manifest.asV0_0_1.network
        : manifest.asV1_0_0.network;
    project.name = await cli_ux_1.cli.prompt('Project name', { default: jsonProjectData.name, required: true });
    project.version = await cli_ux_1.cli.prompt('Project version', { default: jsonProjectData.version, required: true });
    project.runner.node = await inquirer_1.default.prompt([
        {
            name: 'name',
            message: 'select Runner Node spec',
            type: 'list',
            choices: [{ name: SUBSTRATE_NODE_NAME }, { name: TERRA_NODE_NAME }],
        },
    ]);
    project.runner.node.version = await cli_ux_1.cli.prompt('Runner node version', { required: true });
    project.runner.query = await inquirer_1.default.prompt([
        {
            name: 'name',
            message: 'select Runner Query spec',
            type: 'list',
            choices: [{ name: DEFAULT_QUERY_NAME }],
        },
    ]);
    project.runner.query.version = await cli_ux_1.cli.prompt('Runner query version', { required: true });
    let genesisHash;
    if (project.runner.node.name === SUBSTRATE_NODE_NAME) {
        cli_ux_1.cli.action.start('Getting network genesis hash from endpoint for Chain ID');
        try {
            genesisHash = await (0, jsonrpc_1.getGenesisHash)(projectNetwork.endpoint);
        }
        catch (e) {
            genesisHash = null;
        }
        cli_ux_1.cli.action.stop();
    }
    project.chainId = await cli_ux_1.cli.prompt('Please provide Chain ID', { default: genesisHash !== null && genesisHash !== void 0 ? genesisHash : null, required: true });
    if (manifest instanceof common_substrate_1.SubstrateProjectManifestVersioned) {
        if (manifest.isV0_0_1) {
            const projectV1Network = manifest.asV0_0_1.network;
            if (projectV1Network.types ||
                projectV1Network.typesAlias ||
                projectV1Network.typesBundle ||
                projectV1Network.typesChain ||
                projectV1Network.typesSpec) {
                chainTypesRelativePath = await cli_ux_1.cli.prompt('Please provide network chain types path', {
                    default: './types.json',
                    required: true,
                });
                const { ext } = path_1.default.parse(chainTypesRelativePath);
                if (ext !== '.yaml' && ext !== '.yml' && ext !== '.json') {
                    throw new Error(`Extension ${ext} not supported`);
                }
                const projectChainTypesPath = path_1.default.join(location, chainTypesRelativePath);
                //check if the file path is exist, if not create one
                if (fs_1.default.existsSync(projectChainTypesPath)) {
                    if (await cli_ux_1.cli.confirm(`${projectChainTypesPath} already exist, do you want override it [Y/N]`)) {
                        await createChainTypes(projectV1Network, projectChainTypesPath, ext);
                    }
                }
                else {
                    await createChainTypes(projectV1Network, projectChainTypesPath, ext);
                }
            }
            //Patch manifest here
            for (const dataSource of manifest.asV1_0_0.dataSources) {
                dataSource.mapping.file = await cli_ux_1.cli.prompt(`Please provide relative entry path for dataSource ${dataSource.name}'s mapping `, {
                    default: jsonProjectData.main.toString().startsWith('./')
                        ? jsonProjectData.main
                        : `./${jsonProjectData.main}`,
                    required: true,
                });
                delete dataSource.name;
                const handlers = dataSource.mapping.handlers;
                delete dataSource.mapping.handlers; // adjust position
                dataSource.mapping.handlers = handlers;
            }
        }
        else {
            // handle chainTypes path as v0.2.0
            if (manifest.asV0_2_0.network.chaintypes) {
                chainTypesRelativePath = manifest.asV0_2_0.network.chaintypes.file;
            }
        }
    }
    return [project, chainTypesRelativePath];
}
exports.prepare = prepare;
async function migrate(projectPath, project, manifest, chainTypes) {
    var _a, _b;
    const originManifestPath = path_1.default.join(projectPath, MANIFEST_PATH);
    const manifestOld = path_1.default.join(projectPath, MANIFEST_OLD);
    const manifestV1_0_0 = path_1.default.join(projectPath, MANIFEST_V_1_0_0);
    try {
        const data = {};
        data.specVersion = '1.0.0';
        data.name = project.name;
        data.version = project.version;
        data.runner = project.runner;
        data.description = (_a = manifest.asV1_0_0.description) !== null && _a !== void 0 ? _a : '';
        data.repository = (_b = manifest.asV1_0_0.repository) !== null && _b !== void 0 ? _b : '';
        if (manifest instanceof common_substrate_1.SubstrateProjectManifestVersioned) {
            data.schema = manifest.isV0_0_1 ? { file: manifest.asV0_0_1.schema } : manifest.asV1_0_0.schema;
        }
        else if (manifest instanceof common_terra_1.TerraProjectManifestVersioned) {
            data.schema = manifest.asV1_0_0.schema;
        }
        data.network = {
            chainId: project.chainId,
            endpoint: manifest.asV1_0_0.network.endpoint,
        };
        if (manifest.asV1_0_0.network.dictionary) {
            data.network.dictionary = manifest.asV1_0_0.network.dictionary;
        }
        if (chainTypes) {
            data.network.chaintypes = { file: chainTypes };
        }
        data.dataSources = manifest.asV1_0_0.dataSources; //TODO, fix this type as extend BaseDataSource
        manifest instanceof common_substrate_1.SubstrateProjectManifestVersioned && manifest.asV1_0_0.templates
            ? (data.templates = manifest.asV1_0_0.templates)
            : delete data.templates;
        const newYaml = js_yaml_1.default.dump((0, class_transformer_1.classToPlain)(data));
        await fs_1.default.promises.writeFile(manifestV1_0_0, newYaml, 'utf8');
    }
    catch (e) {
        throw new Error(`Failed to create manifest : ${e}`);
    }
    //validate before backup and conversion
    try {
        (0, common_substrate_1.loadSubstrateProjectManifest)(manifestV1_0_0).isV1_0_0;
    }
    catch (e) {
        try {
            (0, common_terra_1.loadTerraProjectManifest)(manifestV1_0_0).isV1_0_0;
        }
        catch (e) {
            console.error(`${manifestV1_0_0} failed validation for manifest spec 1.0.0, \n ${e}`);
            const keep = await cli_ux_1.cli.confirm(`However, do you want keep ${manifestV1_0_0} for inspection before retry? [Y/N]`);
            if (keep) {
                process.exit(0);
            }
            else {
                await fs_1.default.promises.unlink(manifestV1_0_0);
                process.exit(0);
            }
        }
    }
    //conversion
    await conversion(originManifestPath, manifestOld, manifestV1_0_0);
}
exports.migrate = migrate;
async function conversion(originManifestPath, manifestOld, manifestV1_0_0) {
    try {
        await fs_1.default.promises.rename(originManifestPath, manifestOld);
    }
    catch (e) {
        throw new Error(`Failed convert ${originManifestPath} to ${manifestOld},${e}`);
    }
    try {
        await fs_1.default.promises.rename(manifestV1_0_0, originManifestPath);
    }
    catch (e) {
        throw new Error(`Failed convert ${manifestV1_0_0} to ${originManifestPath},${e}`);
    }
}
async function createChainTypes(projectV1Network, absolutePath, ext) {
    const data = {};
    if (projectV1Network.types)
        data.types = projectV1Network.types;
    if (projectV1Network.typesBundle)
        data.typesBundle = projectV1Network.typesBundle;
    if (projectV1Network.typesAlias)
        data.typesAlias = projectV1Network.typesAlias;
    if (projectV1Network.typesChain)
        data.typesChain = projectV1Network.typesChain;
    if (projectV1Network.typesSpec)
        data.typesChain = projectV1Network.typesSpec;
    if (ext === '.json') {
        await fs_1.default.promises.writeFile(absolutePath, JSON.stringify(data, null, 2));
    }
    else {
        await fs_1.default.promises.writeFile(absolutePath, js_yaml_1.default.dump(data), 'utf8');
    }
    console.log(`* chainTypes is created`);
}
exports.createChainTypes = createChainTypes;
//# sourceMappingURL=migrate-controller.js.map
"use strict";
// Copyright 2020-2022 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.imageVersions = exports.processEndpoints = exports.networkEndpoints = exports.dictionaryEndpoints = exports.ipfsCID_validate = exports.redeploy = exports.projectsInfo = exports.deploymentStatus = exports.deleteDeployment = exports.promoteDeployment = exports.deployToHostedService = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const utils_1 = require("../utils");
async function deployToHostedService(org, projectName, authToken, ipfsCID, indexerImageVersion, queryImageVersion, endpoint, type, dictEndpoint, query, indexer, url) {
    try {
        const result = (await (0, axios_1.default)({
            headers: {
                Authorization: `Bearer ${authToken}`,
            },
            method: 'post',
            url: `v2/subqueries/${(0, utils_1.buildProjectKey)(org, projectName)}/deployments`,
            baseURL: url,
            data: {
                version: ipfsCID,
                dictEndpoint: dictEndpoint,
                endpoint: endpoint,
                advancedSettings: {
                    query: query,
                    indexer: indexer,
                },
                indexerImageVersion: indexerImageVersion,
                queryImageVersion: queryImageVersion,
                type: type,
            },
        })).data;
        return result.deployment;
    }
    catch (e) {
        (0, utils_1.errorHandle)(e, 'Error deploying to hosted service:');
    }
}
exports.deployToHostedService = deployToHostedService;
async function promoteDeployment(org, projectName, authToken, deploymentId, url) {
    try {
        await (0, axios_1.default)({
            headers: {
                Authorization: `Bearer ${authToken}`,
            },
            method: 'post',
            url: `subqueries/${(0, utils_1.buildProjectKey)(org, projectName)}/deployments/${deploymentId}/release`,
            baseURL: url,
        });
        return `${deploymentId}`;
    }
    catch (e) {
        (0, utils_1.errorHandle)(e, 'Failed to promote project:');
    }
}
exports.promoteDeployment = promoteDeployment;
async function deleteDeployment(org, projectName, authToken, deploymentId, url) {
    try {
        await (0, axios_1.default)({
            headers: {
                Authorization: `Bearer ${authToken}`,
            },
            method: 'delete',
            url: `subqueries/${(0, utils_1.buildProjectKey)(org, projectName)}/deployments/${deploymentId}`,
            baseURL: url,
        });
        return `${deploymentId}`;
    }
    catch (e) {
        (0, utils_1.errorHandle)(e, 'Failed to delete deployment:');
    }
}
exports.deleteDeployment = deleteDeployment;
async function deploymentStatus(org, projectName, authToken, deployID, url) {
    try {
        const result = (await (0, axios_1.default)({
            headers: {
                Authorization: `Bearer ${authToken}`,
            },
            method: 'get',
            url: `subqueries/${(0, utils_1.buildProjectKey)(org, projectName)}/deployments/${deployID}/status`,
            baseURL: url,
        })).data;
        return `${result.status}`;
    }
    catch (e) {
        (0, utils_1.errorHandle)(e, 'Failed to get deployment status:');
    }
}
exports.deploymentStatus = deploymentStatus;
async function projectsInfo(authToken, org, projectName, url, type) {
    const key = `${org}/${projectName}`;
    try {
        const result = (await (0, axios_1.default)({
            headers: {
                Authorization: `Bearer ${authToken}`,
            },
            method: 'get',
            url: `subqueries/${(0, utils_1.buildProjectKey)(org, projectName)}/deployments`,
            baseURL: url,
        })).data;
        return result.find((element) => element.projectKey === `${key}` && element.type === type);
    }
    catch (e) {
        (0, utils_1.errorHandle)(e, 'Failed to get projects:');
    }
}
exports.projectsInfo = projectsInfo;
async function redeploy(org, projectName, deployID, authToken, ipfsCID, endpoint, dictEndpoint, indexerVersion, queryVersion, query, indexer, url) {
    try {
        await (0, axios_1.default)({
            headers: {
                Authorization: `Bearer ${authToken}`,
            },
            method: 'put',
            url: `v2/subqueries/${(0, utils_1.buildProjectKey)(org, projectName)}/deployments/${deployID}`,
            baseURL: url,
            data: {
                version: ipfsCID,
                dictEndpoint: dictEndpoint,
                endpoint: endpoint,
                indexerImageVersion: indexerVersion,
                queryImageVersion: queryVersion,
                advancedSettings: {
                    query: query,
                    indexer: indexer,
                },
            },
        });
    }
    catch (e) {
        (0, utils_1.errorHandle)(e, `Failed to redeploy project: ${e.message}`);
    }
}
exports.redeploy = redeploy;
async function ipfsCID_validate(cid, authToken, url) {
    try {
        const result = (await (0, axios_1.default)({
            headers: {
                Authorization: `Bearer ${authToken}`,
            },
            method: 'post',
            url: `ipfs/deployment-id/${cid}/validate`,
            baseURL: url,
        })).data;
        return result;
    }
    catch (e) {
        (0, utils_1.errorHandle)(e, 'Failed to validate IPFS CID:');
    }
}
exports.ipfsCID_validate = ipfsCID_validate;
async function dictionaryEndpoints(url) {
    try {
        const result = (await (0, axios_1.default)({
            method: 'get',
            url: `subqueries/dictionaries`,
            baseURL: url,
        })).data;
        return result;
    }
    catch (e) {
        (0, utils_1.errorHandle)(e, 'Failed to get dictionary endpoint:');
    }
}
exports.dictionaryEndpoints = dictionaryEndpoints;
async function networkEndpoints(url) {
    try {
        const result = (await (0, axios_1.default)({
            method: 'get',
            url: `subqueries/network-endpoints`,
            baseURL: url,
        })).data;
        return result;
    }
    catch (e) {
        (0, utils_1.errorHandle)(e, 'Failed to get endpoint:');
    }
}
exports.networkEndpoints = networkEndpoints;
function processEndpoints(endpoints, chainId) {
    var _a;
    return (_a = endpoints.find((endpoint) => endpoint.chainId === chainId)) === null || _a === void 0 ? void 0 : _a.endpoint;
}
exports.processEndpoints = processEndpoints;
async function imageVersions(name, version, authToken, url) {
    try {
        const result = (await (0, axios_1.default)({
            headers: { Authorization: `Bearer ${authToken}` },
            method: 'get',
            url: `info/images/${encodeURIComponent(name)}?version=${encodeURIComponent(version)}`,
            baseURL: url,
        })).data;
        return result;
    }
    catch (e) {
        (0, utils_1.errorHandle)(e, 'Failed to get image:');
    }
}
exports.imageVersions = imageVersions;
//# sourceMappingURL=deploy-controller.js.map
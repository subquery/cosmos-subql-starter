"use strict";
// Copyright 2020-2022 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const util_1 = require("util");
const common_1 = require("@subql/common");
const rimraf_1 = tslib_1.__importDefault(require("rimraf"));
const yaml_1 = require("yaml");
const types_1 = require("../types");
const init_controller_1 = require("./init-controller");
async function testYAML(projectPath, project) {
    var _a, _b;
    const yamlPath = path_1.default.join(`${projectPath}`, `project.yaml`);
    const manifest = await fs.promises.readFile(yamlPath, 'utf8');
    const data = (0, yaml_1.parseDocument)(manifest);
    const clonedData = data.clone();
    clonedData.set('description', (_a = project.description) !== null && _a !== void 0 ? _a : data.get('description'));
    clonedData.set('repository', (_b = project.repository) !== null && _b !== void 0 ? _b : '');
    // network type should be collection
    const network = clonedData.get('network');
    network.set('endpoint', 'http://def not real endpoint');
    clonedData.set('version', 'not real version');
    clonedData.set('name', 'not real name');
    if ((0, types_1.isProjectSpecV1_0_0)(project)) {
        network.set('chainId', 'random chainId');
    }
    else if ((0, types_1.isProjectSpecV0_2_0)(project)) {
        network.set('genesisHash', 'random genesisHash');
    }
    return {
        old: data,
        new: clonedData,
    };
}
// async
const fileExists = async (file) => {
    return new Promise((resolve, reject) => {
        fs.access(file, fs.constants.F_OK, (err) => {
            err ? reject(err) : resolve(true);
        });
    });
};
jest.setTimeout(30000);
const projectSpec = {
    name: 'mocked_starter',
    repository: '',
    endpoint: 'wss://rpc.polkadot.io/public-ws',
    specVersion: '1.0.0',
    author: 'jay',
    description: 'this is test for init controller',
    chainId: '0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3',
    version: '',
    license: '',
};
describe('Cli can create project', () => {
    it('should resolve when starter project created via template', async () => {
        const tempPath = await (0, common_1.makeTempDir)();
        const templates = await (0, init_controller_1.fetchTemplates)();
        const projectPath = await (0, init_controller_1.cloneProjectTemplate)(tempPath, projectSpec.name, templates[0]);
        await (0, init_controller_1.prepare)(projectPath, projectSpec);
        await expect(fileExists(path_1.default.join(tempPath, `${projectSpec.name}`))).resolves.toEqual(true);
    });
    it('should resolve when starter project created via git', async () => {
        const tempPath = await (0, common_1.makeTempDir)();
        const projectPath = await (0, init_controller_1.cloneProjectGit)(tempPath, projectSpec.name, 'https://github.com/subquery/subql-starter', 'v1.0.0');
        await (0, init_controller_1.prepare)(projectPath, projectSpec);
        await expect(fileExists(path_1.default.join(tempPath, `${projectSpec.name}`))).resolves.toEqual(true);
    });
    it('throw error if .git exists in starter project', async () => {
        const tempPath = await (0, common_1.makeTempDir)();
        const templates = await (0, init_controller_1.fetchTemplates)();
        const projectPath = await (0, init_controller_1.cloneProjectTemplate)(tempPath, projectSpec.name, templates[0]);
        await (0, init_controller_1.prepare)(projectPath, projectSpec);
        await expect(fileExists(path_1.default.join(tempPath, `${projectSpec.name}/.git`))).rejects.toThrow();
    });
    it('YAML contains comments', async () => {
        const tempPath = await (0, common_1.makeTempDir)();
        const templates = await (0, init_controller_1.fetchTemplates)();
        const projectPath = await (0, init_controller_1.cloneProjectTemplate)(tempPath, projectSpec.name, templates[0]);
        const output = await testYAML(projectPath, projectSpec);
        expect(output.new.toJS().network.chainId).toBe('random chainId');
        expect(output.new).not.toEqual(output.old);
        expect(output.new.toString()).toContain('# The genesis hash of the network (hash of block 0)');
        await (0, util_1.promisify)(rimraf_1.default)(tempPath);
    });
    it('prepare correctly applies project details', async () => {
        const tempPath = await (0, common_1.makeTempDir)();
        const templates = await (0, init_controller_1.fetchTemplates)();
        const template = templates.find(({ name }) => name.toLowerCase() === 'polkadot-starter');
        const projectPath = await (0, init_controller_1.cloneProjectTemplate)(tempPath, projectSpec.name, template);
        await (0, init_controller_1.prepare)(projectPath, projectSpec);
        const [specVersion, repository, endpoint, author, version, description, license] = await (0, init_controller_1.readDefaults)(projectPath);
        expect(projectSpec.specVersion).toEqual(specVersion);
        expect(projectSpec.repository).toEqual(repository);
        expect(projectSpec.endpoint).toEqual(endpoint);
        expect(projectSpec.author).toEqual(author);
        expect(projectSpec.version).toEqual(version);
        expect(projectSpec.description).toEqual(description);
        expect(projectSpec.license).toEqual(license);
    });
    it('allow git from sub directory', async () => {
        const tempPath = await (0, common_1.makeTempDir)();
        const template = {
            remote: 'https://github.com/subquery/subql-starter',
            family: 'Substrate',
            branch: 'main',
            network: 'Polkadot',
            name: 'Polkadot-starter',
            description: '',
        };
        const projectPath = await (0, init_controller_1.cloneProjectTemplate)(tempPath, projectSpec.name, template);
        await (0, init_controller_1.prepare)(projectPath, projectSpec);
        await expect(fileExists(path_1.default.join(tempPath, `${projectSpec.name}`))).resolves.toEqual(true);
    }, 5000000);
});
//# sourceMappingURL=init-controller.test.js.map
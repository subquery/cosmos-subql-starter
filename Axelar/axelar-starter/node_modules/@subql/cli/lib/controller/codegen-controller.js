"use strict";
// Copyright 2020-2022 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateDatasourceTemplates = exports.generateModels = exports.codegen = exports.processFields = exports.generateEnums = exports.generateJsonInterfaces = exports.renderTemplate = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const util_1 = require("util");
const common_1 = require("@subql/common");
const common_substrate_1 = require("@subql/common-substrate");
const common_terra_1 = require("@subql/common-terra");
const utils_1 = require("@subql/utils");
const ejs_1 = tslib_1.__importDefault(require("ejs"));
const lodash_1 = require("lodash");
const rimraf_1 = tslib_1.__importDefault(require("rimraf"));
let MODEL_TEMPLATE_PATH = path_1.default.resolve(__dirname, '../template/model.ts.ejs');
const MODELS_INDEX_TEMPLATE_PATH = path_1.default.resolve(__dirname, '../template/models-index.ts.ejs');
const TYPES_INDEX_TEMPLATE_PATH = path_1.default.resolve(__dirname, '../template/types-index.ts.ejs');
const INTERFACE_TEMPLATE_PATH = path_1.default.resolve(__dirname, '../template/interface.ts.ejs');
const ENUM_TEMPLATE_PATH = path_1.default.resolve(__dirname, '../template/enum.ts.ejs');
const DYNAMIC_DATASOURCE_TEMPLATE_PATH = path_1.default.resolve(__dirname, '../template/datasource-templates.ts.ejs');
const TYPE_ROOT_DIR = 'src/types';
const MODEL_ROOT_DIR = 'src/types/models';
const exportTypes = {
    models: false,
    interfaces: false,
    enums: false,
    datasources: false,
};
// 4. Render entity data in ejs template and write it
async function renderTemplate(templatePath, outputPath, templateData) {
    const data = await ejs_1.default.renderFile(templatePath, templateData);
    await fs_1.default.promises.writeFile(outputPath, data);
}
exports.renderTemplate = renderTemplate;
async function generateJsonInterfaces(projectPath, schema) {
    const typesDir = path_1.default.join(projectPath, TYPE_ROOT_DIR);
    const jsonObjects = (0, utils_1.getAllJsonObjects)(schema);
    const jsonInterfaces = jsonObjects.map((r) => {
        const object = (0, utils_1.setJsonObjectType)(r, jsonObjects);
        const fields = processFields('jsonField', object.name, object.fields);
        return {
            interfaceName: object.name,
            fields,
        };
    });
    if (jsonInterfaces.length !== 0) {
        const interfaceTemplate = {
            props: {
                jsonInterfaces,
            },
            helper: {
                upperFirst: lodash_1.upperFirst,
            },
        };
        try {
            await renderTemplate(INTERFACE_TEMPLATE_PATH, path_1.default.join(typesDir, `interfaces.ts`), interfaceTemplate);
            exportTypes.interfaces = true;
        }
        catch (e) {
            throw new Error(`When render json interfaces having problems.`);
        }
    }
}
exports.generateJsonInterfaces = generateJsonInterfaces;
async function generateEnums(projectPath, schema) {
    const typesDir = path_1.default.join(projectPath, TYPE_ROOT_DIR);
    const jsonObjects = (0, utils_1.getAllEnums)(schema);
    const enums = jsonObjects.map((r) => {
        return {
            name: r.name,
            values: r.getValues().map((v) => v.name),
        };
    });
    if (enums.length !== 0) {
        const enumsTemplate = {
            props: {
                enums,
            },
        };
        try {
            await renderTemplate(ENUM_TEMPLATE_PATH, path_1.default.join(typesDir, `enums.ts`), enumsTemplate);
            exportTypes.enums = true;
        }
        catch (e) {
            throw new Error(`When render enums having problems.`);
        }
    }
}
exports.generateEnums = generateEnums;
function processFields(type, className, fields, indexFields = []) {
    const fieldList = [];
    for (const field of fields) {
        const injectField = {
            name: field.name,
            required: !field.nullable,
            isArray: field.isArray,
            isEnum: false,
        };
        if (type === 'entity') {
            const [indexed, unique] = indexFields.reduce((acc, indexField) => {
                if (indexField.fields.includes(field.name)) {
                    acc[0] = true;
                    if (indexField.fields.length === 1 && indexField.unique) {
                        acc[1] = true;
                    }
                    else if (indexField.unique === undefined) {
                        acc[1] = false;
                    }
                }
                return acc;
            }, [false, undefined]);
            injectField.indexed = indexed;
            injectField.unique = unique;
        }
        if (field.isEnum) {
            injectField.type = field.type;
            injectField.isEnum = true;
            injectField.isJsonInterface = false;
        }
        else {
            switch (field.type) {
                default: {
                    injectField.type = (0, utils_1.getTypeByScalarName)(field.type).tsType;
                    if (!injectField.type) {
                        throw new Error(`Schema: undefined type "${field.type.toString()}" on field "${field.name}" in "type ${className} @${type}"`);
                    }
                    injectField.isJsonInterface = false;
                    break;
                }
                case 'Json': {
                    if (field.jsonInterface === undefined) {
                        throw new Error(`On field ${field.name} type is Json but json interface is not defined`);
                    }
                    injectField.type = (0, lodash_1.upperFirst)(field.jsonInterface.name);
                    injectField.isJsonInterface = true;
                }
            }
        }
        fieldList.push(injectField);
    }
    return fieldList;
}
exports.processFields = processFields;
async function prepareDirPath(path, recreate) {
    try {
        await (0, util_1.promisify)(rimraf_1.default)(path);
        if (recreate) {
            await fs_1.default.promises.mkdir(path, { recursive: true });
        }
    }
    catch (e) {
        throw new Error(`Failed to prepare ${path}`);
    }
}
//1. Prepare models directory and load schema
async function codegen(projectPath, fileName) {
    const modelDir = path_1.default.join(projectPath, MODEL_ROOT_DIR);
    const interfacesPath = path_1.default.join(projectPath, TYPE_ROOT_DIR, `interfaces.ts`);
    await prepareDirPath(modelDir, true);
    await prepareDirPath(interfacesPath, false);
    const plainManifest = (0, common_1.loadFromJsonOrYaml)((0, common_1.getManifestPath)(projectPath, fileName));
    if (plainManifest.templates && plainManifest.templates.length !== 0) {
        await generateDatasourceTemplates(projectPath, plainManifest.specVersion, plainManifest.templates);
    }
    const schemaPath = (0, common_1.getSchemaPath)(projectPath, fileName);
    await generateJsonInterfaces(projectPath, schemaPath);
    await generateModels(projectPath, schemaPath);
    await generateEnums(projectPath, schemaPath);
    if (exportTypes.interfaces || exportTypes.models || exportTypes.enums || exportTypes.datasources) {
        try {
            await renderTemplate(TYPES_INDEX_TEMPLATE_PATH, path_1.default.join(projectPath, TYPE_ROOT_DIR, `index.ts`), {
                props: {
                    exportTypes,
                },
            });
        }
        catch (e) {
            throw new Error(`When render index in types having problems.`);
        }
        console.log(`* Types index generated !`);
    }
}
exports.codegen = codegen;
// 2. Loop all entities and render it
async function generateModels(projectPath, schema) {
    const extractEntities = (0, utils_1.getAllEntitiesRelations)(schema);
    for (const entity of extractEntities.models) {
        const baseFolderPath = '.../../base';
        const className = (0, lodash_1.upperFirst)(entity.name);
        const entityName = entity.name;
        const fields = processFields('entity', className, entity.fields, entity.indexes);
        const importJsonInterfaces = (0, lodash_1.uniq)(fields.filter((field) => field.isJsonInterface).map((f) => f.type));
        const importEnums = fields.filter((field) => field.isEnum).map((f) => f.type);
        const indexedFields = fields.filter((field) => field.indexed && !field.isJsonInterface);
        const modelTemplate = {
            props: {
                baseFolderPath,
                className,
                entityName,
                fields,
                importJsonInterfaces,
                importEnums,
                indexedFields,
            },
            helper: {
                upperFirst: lodash_1.upperFirst,
            },
        };
        try {
            await renderTemplate(MODEL_TEMPLATE_PATH, path_1.default.join(projectPath, MODEL_ROOT_DIR, `${className}.ts`), modelTemplate);
        }
        catch (e) {
            console.error(e);
            throw new Error(`When render entity ${className} to schema having problems.`);
        }
        console.log(`* Schema ${className} generated !`);
    }
    const classNames = extractEntities.models.map((entity) => entity.name);
    if (classNames.length !== 0) {
        try {
            await renderTemplate(MODELS_INDEX_TEMPLATE_PATH, path_1.default.join(projectPath, MODEL_ROOT_DIR, `index.ts`), {
                props: {
                    classNames,
                },
                helper: {
                    upperFirst: lodash_1.upperFirst,
                },
            });
            exportTypes.models = true;
        }
        catch (e) {
            throw new Error(`When render index in models having problems.`);
        }
        console.log(`* Models index generated !`);
    }
}
exports.generateModels = generateModels;
async function generateDatasourceTemplates(projectPath, specVersion, templates) {
    let props;
    if ((0, common_substrate_1.isSubstrateTemplates)(templates, specVersion)) {
        props = templates.map((t) => ({
            name: t.name,
            args: (0, common_substrate_1.isCustomDs)(t) ? 'Record<string, unknown>' : undefined,
        }));
    }
    else if ((0, common_terra_1.isTerraTemplates)(templates, specVersion)) {
        props = templates.map((t) => ({
            name: t.name,
            args: 'Record<string, unknown>',
        }));
        MODEL_TEMPLATE_PATH = path_1.default.resolve(__dirname, '../template/terramodel.ts.ejs');
    }
    else {
        throw new Error(`Generated datasource templates failed: unsupported templates`);
    }
    try {
        await renderTemplate(DYNAMIC_DATASOURCE_TEMPLATE_PATH, path_1.default.join(projectPath, TYPE_ROOT_DIR, `datasources.ts`), {
            props,
        });
        exportTypes.datasources = true;
    }
    catch (e) {
        console.error(e);
        throw new Error(`Unable to generate datasource template constructors`);
    }
    console.log(`* Datasource template constructors generated !`);
}
exports.generateDatasourceTemplates = generateDatasourceTemplates;
//# sourceMappingURL=codegen-controller.js.map
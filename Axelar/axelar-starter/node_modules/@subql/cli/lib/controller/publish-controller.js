"use strict";
// Copyright 2020-2022 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadFile = exports.uploadToIpfs = exports.createIPFSFile = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const common_1 = require("@subql/common");
const common_algorand_1 = require("@subql/common-algorand");
const common_avalanche_1 = require("@subql/common-avalanche");
const common_cosmos_1 = require("@subql/common-cosmos");
const common_ethereum_1 = require("@subql/common-ethereum");
const common_flare_1 = require("@subql/common-flare");
const common_substrate_1 = require("@subql/common-substrate");
const common_terra_1 = require("@subql/common-terra");
const axios_1 = tslib_1.__importDefault(require("axios"));
const form_data_1 = tslib_1.__importDefault(require("form-data"));
const ipfs_http_client_1 = require("ipfs-http-client");
async function createIPFSFile(projectPath, cid) {
    const filePath = (0, common_1.getProjectRootAndManifest)(projectPath);
    const { name } = path_1.default.parse(filePath.manifest);
    const MANIFEST_FILE = path_1.default.join(filePath.root, `.${name}-cid`);
    try {
        await fs_1.default.promises.writeFile(MANIFEST_FILE, cid, 'utf8');
    }
    catch (e) {
        throw new Error(`Failed to create CID file: ${e}`);
    }
}
exports.createIPFSFile = createIPFSFile;
async function uploadToIpfs(projectPath, authToken, ipfsEndpoint) {
    const reader = await common_1.ReaderFactory.create(projectPath);
    let manifest;
    const schema = await reader.getProjectSchema();
    //substrate
    try {
        manifest = (0, common_substrate_1.parseSubstrateProjectManifest)(schema).asImpl;
        if ((0, common_substrate_1.manifestIsV0_0_1)(manifest)) {
            throw new Error('Unsupported project manifest spec, only 0.2.0 or greater is supported');
        }
    }
    catch (e) {
        //terra
        try {
            manifest = (0, common_terra_1.parseTerraProjectManifest)(schema).asImpl;
        }
        catch (e) {
            // cosmos
            try {
                manifest = (0, common_cosmos_1.parseCosmosProjectManifest)(schema).asImpl;
            }
            catch (e) {
                //avalanche
                try {
                    manifest = (0, common_avalanche_1.parseSubstrateProjectManifest)(schema).asImpl;
                }
                catch (e) {
                    // algorand
                    try {
                        manifest = (0, common_algorand_1.parseAlgorandProjectManifest)(schema).asImpl;
                    }
                    catch (e) {
                        try {
                            manifest = (0, common_ethereum_1.parseEthereumProjectManifest)(schema).asImpl;
                        }
                        catch (e) {
                            try {
                                manifest = (0, common_flare_1.parseEthereumProjectManifest)(schema).asImpl;
                            }
                            catch (e) {
                                throw new Error('Unable to pass project manifest');
                            }
                        }
                    }
                }
            }
        }
    }
    let ipfs;
    if (ipfsEndpoint) {
        ipfs = (0, ipfs_http_client_1.create)({ url: ipfsEndpoint });
    }
    const deployment = await replaceFileReferences(reader.root, manifest, authToken, ipfs);
    // Upload schema
    return uploadFile(deployment.toDeployment(), authToken, ipfs);
}
exports.uploadToIpfs = uploadToIpfs;
/* Recursively finds all FileReferences in an object and replaces the files with IPFS references */
async function replaceFileReferences(projectDir, input, authToken, ipfs) {
    if (Array.isArray(input)) {
        return (await Promise.all(input.map((val) => replaceFileReferences(projectDir, val, authToken, ipfs))));
    }
    else if (typeof input === 'object' && input !== null) {
        if (input instanceof Map) {
            input = mapToObject(input);
        }
        if (isFileReference(input)) {
            input.file = await uploadFile(fs_1.default.createReadStream(path_1.default.resolve(projectDir, input.file)), authToken, ipfs).then((cid) => `ipfs://${cid}`);
        }
        const keys = Object.keys(input);
        await Promise.all(keys.map(async (key) => {
            // this is the loop
            input[key] = await replaceFileReferences(projectDir, input[key], authToken, ipfs);
        }));
    }
    return input;
}
const fileMap = new Map();
async function uploadFile(content, authToken, ipfs) {
    let ipfsClientCid;
    if (ipfs) {
        try {
            ipfsClientCid = (await ipfs.add(content, { pin: true, cidVersion: 0 })).cid.toString();
        }
        catch (e) {
            throw new Error(`Publish project to provided IPFS gateway failed, ${e}`);
        }
    }
    let ipfsClusterCid;
    try {
        if (fileMap.has(content)) {
            ipfsClusterCid = fileMap.get(content);
        }
        else {
            ipfsClusterCid = await uploadFileByCluster(determineStringOrFsStream(content) ? await fs_1.default.promises.readFile(content.path, 'utf8') : content, authToken);
            fileMap.set(content, ipfsClusterCid);
        }
    }
    catch (e) {
        throw new Error(`Publish project to default cluster failed, ${e}`);
    }
    // Validate IPFS cid
    if (ipfsClientCid && ipfsClientCid !== ipfsClusterCid) {
        throw new Error(`Published and received IPFS cid not identical \n,
    IPFS gateway: ${ipfsClientCid}, IPFS cluster: ${ipfsClusterCid}`);
    }
    return ipfsClusterCid;
}
exports.uploadFile = uploadFile;
function determineStringOrFsStream(toBeDetermined) {
    return !!toBeDetermined.path;
}
async function uploadFileByCluster(content, authToken) {
    var _a;
    const bodyFormData = new form_data_1.default();
    bodyFormData.append('data', content);
    const result = (await (0, axios_1.default)({
        headers: Object.assign({ Authorization: `Bearer ${authToken}`, 'Content-Type': 'multipart/form-data' }, bodyFormData.getHeaders()),
        method: 'post',
        url: common_1.IPFS_CLUSTER_ENDPOINT,
        data: bodyFormData,
        maxBodyLength: 50 * 1024 * 1024,
        maxContentLength: 50 * 1024 * 1024,
    })).data;
    if (typeof result.cid === 'string') {
        return result.cid;
    }
    const cid = (_a = result.cid) === null || _a === void 0 ? void 0 : _a['/'];
    if (!cid) {
        throw new Error('Failed to get CID from response');
    }
    return cid;
}
function mapToObject(map) {
    // XXX can use Object.entries with newer versions of node.js
    const assetsObj = {};
    for (const key of map.keys()) {
        assetsObj[key] = map.get(key);
    }
    return assetsObj;
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isFileReference(value) {
    return (value === null || value === void 0 ? void 0 : value.file) && typeof value.file === 'string';
}
//# sourceMappingURL=publish-controller.js.map
"use strict";
// Copyright 2020-2022 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.installDependencies = exports.prepare = exports.readDefaults = exports.cloneProjectTemplate = exports.cloneProjectGit = exports.fetchTemplates = void 0;
const tslib_1 = require("tslib");
const child_process_1 = tslib_1.__importStar(require("child_process"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const path = tslib_1.__importStar(require("path"));
const util_1 = require("util");
const common_1 = require("@subql/common");
const axios_1 = tslib_1.__importDefault(require("axios"));
const fs_extra_1 = require("fs-extra");
const rimraf_1 = tslib_1.__importDefault(require("rimraf"));
const simple_git_1 = tslib_1.__importDefault(require("simple-git"));
const yaml_1 = require("yaml");
const types_1 = require("../types");
const TEMPLATES_REMOTE = 'https://raw.githubusercontent.com/subquery/templates/main/templates.json';
async function fetchTemplates(remote = TEMPLATES_REMOTE) {
    return axios_1.default
        .create()
        .get(remote)
        .then(({ data }) => data)
        .catch((err) => {
        throw new Error(`Unable to reach endpoint '${remote}', ${err}`);
    });
}
exports.fetchTemplates = fetchTemplates;
async function cloneProjectGit(localPath, projectName, projectRemote, branch) {
    const projectPath = path.join(localPath, projectName);
    try {
        await (0, simple_git_1.default)().clone(projectRemote, projectPath, ['-b', branch, '--single-branch']);
    }
    catch (e) {
        let err = 'Failed to clone starter template from git';
        try {
            (0, child_process_1.execSync)('git --version');
        }
        catch (_) {
            err += ', please install git and ensure that it is available from command line';
        }
        throw new Error(err);
    }
    return projectPath;
}
exports.cloneProjectGit = cloneProjectGit;
async function cloneProjectTemplate(localPath, projectName, selectedTemplate) {
    const projectPath = path.join(localPath, projectName);
    //make temp directory to store project
    const tempPath = await (0, common_1.makeTempDir)();
    //use sparse-checkout to clone project to temp directory
    await (0, simple_git_1.default)(tempPath).init().addRemote('origin', selectedTemplate.remote);
    await (0, simple_git_1.default)(tempPath).raw('sparse-checkout', 'set', `${selectedTemplate.network}/${selectedTemplate.name}`);
    await (0, simple_git_1.default)(tempPath).raw('pull', 'origin', selectedTemplate.branch);
    // Copy content to project path
    (0, fs_extra_1.copySync)(path.join(tempPath, `${selectedTemplate.network}/${selectedTemplate.name}`), projectPath);
    // Clean temp folder
    fs_1.default.rmSync(tempPath, { recursive: true, force: true });
    return projectPath;
}
exports.cloneProjectTemplate = cloneProjectTemplate;
async function readDefaults(projectPath) {
    const packageData = await fs_1.default.promises.readFile(`${projectPath}/package.json`);
    const currentPackage = JSON.parse(packageData.toString());
    const yamlPath = path.join(`${projectPath}`, `project.yaml`);
    const manifest = await fs_1.default.promises.readFile(yamlPath, 'utf8');
    const currentProject = (0, yaml_1.parseDocument)(manifest).toJS();
    return [
        currentProject.specVersion,
        currentProject.repository,
        currentProject.network.endpoint,
        currentPackage.author,
        currentPackage.version,
        currentPackage.description,
        currentPackage.license,
    ];
}
exports.readDefaults = readDefaults;
async function prepare(projectPath, project) {
    try {
        await prepareManifest(projectPath, project);
    }
    catch (e) {
        throw new Error('Failed to prepare read or write manifest while preparing the project');
    }
    try {
        await preparePackage(projectPath, project);
    }
    catch (e) {
        throw new Error('Failed to prepare read or write package.json while preparing the project');
    }
    try {
        await (0, util_1.promisify)(rimraf_1.default)(`${projectPath}/.git`);
    }
    catch (e) {
        throw new Error('Failed to remove .git from template project');
    }
}
exports.prepare = prepare;
async function preparePackage(projectPath, project) {
    var _a;
    //load and write package.json
    const packageData = await fs_1.default.promises.readFile(`${projectPath}/package.json`);
    const currentPackage = JSON.parse(packageData.toString());
    currentPackage.name = project.name;
    currentPackage.version = project.version;
    currentPackage.description = (_a = project.description) !== null && _a !== void 0 ? _a : currentPackage.description;
    currentPackage.author = project.author;
    currentPackage.license = project.license;
    const newPackage = JSON.stringify(currentPackage, null, 2);
    await fs_1.default.promises.writeFile(`${projectPath}/package.json`, newPackage, 'utf8');
}
async function prepareManifest(projectPath, project) {
    var _a, _b;
    //load and write manifest(project.yaml)
    const yamlPath = path.join(`${projectPath}`, `project.yaml`);
    const manifest = await fs_1.default.promises.readFile(yamlPath, 'utf8');
    const data = (0, yaml_1.parseDocument)(manifest);
    const clonedData = data.clone();
    clonedData.set('description', (_a = project.description) !== null && _a !== void 0 ? _a : data.get('description'));
    clonedData.set('repository', (_b = project.repository) !== null && _b !== void 0 ? _b : '');
    const network = clonedData.get('network');
    network.set('endpoint', project.endpoint);
    clonedData.set('version', project.version);
    clonedData.set('name', project.name);
    if ((0, types_1.isProjectSpecV1_0_0)(project)) {
        network.set('chainId', project.chainId);
    }
    else if ((0, types_1.isProjectSpecV0_2_0)(project)) {
        network.set('genesisHash', project.genesisHash);
    }
    await fs_1.default.promises.writeFile(yamlPath, clonedData.toString(), 'utf8');
}
function installDependencies(projectPath, useNpm) {
    let command = 'yarn install';
    if (useNpm || !checkYarnExists()) {
        command = 'npm install';
    }
    child_process_1.default.execSync(command, { cwd: projectPath });
}
exports.installDependencies = installDependencies;
function checkYarnExists() {
    try {
        child_process_1.default.execSync('yarn --version');
        return true;
    }
    catch (e) {
        return false;
    }
}
//# sourceMappingURL=init-controller.js.map
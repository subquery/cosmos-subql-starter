"use strict";
// Copyright 2020-2022 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTestProject = exports.projectSpecV1_0_0 = void 0;
const tslib_1 = require("tslib");
const child_process_1 = tslib_1.__importDefault(require("child_process"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const util_1 = require("util");
const common_1 = require("@subql/common");
const common_substrate_1 = require("@subql/common-substrate");
const ipfs_http_client_1 = require("ipfs-http-client");
const rimraf_1 = tslib_1.__importDefault(require("rimraf"));
const build_1 = tslib_1.__importDefault(require("../commands/build"));
const codegen_1 = tslib_1.__importDefault(require("../commands/codegen"));
const publish_1 = tslib_1.__importDefault(require("../commands/publish"));
const init_controller_1 = require("./init-controller");
const publish_controller_1 = require("./publish-controller");
const projectSpecV0_0_1 = {
    name: 'mocked_starter',
    repository: '',
    endpoint: 'wss://rpc.polkadot.io/public-ws',
    author: 'jay',
    description: 'this is test for init controller',
    version: '',
    license: '',
};
const projectSpecV0_2_0 = {
    name: 'mocked_starter',
    repository: '',
    genesisHash: '0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3',
    endpoint: 'wss://rpc.polkadot.io/public-ws',
    author: 'jay',
    description: 'this is test for init controller',
    version: '',
    license: '',
};
exports.projectSpecV1_0_0 = {
    name: 'mocked_starter',
    repository: '',
    chainId: '0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3',
    endpoint: 'wss://rpc.polkadot.io/public-ws',
    author: 'jay',
    description: 'this is test for init controller',
    version: '',
    license: '',
    runner: {
        node: {
            name: '@subql/node',
            version: '>=1.0.0',
        },
        query: {
            name: '@subql/query',
            version: '*',
        },
    },
};
const ipfsEndpoint = 'http://localhost:5001/api/v0';
// Replace/Update your access token when test locally
const testAuth = process.env.SUBQL_ACCESS_TOKEN;
jest.setTimeout(150000);
async function createTestProject(projectSpec) {
    const tmpdir = await fs_1.default.promises.mkdtemp(`${os_1.default.tmpdir()}${path_1.default.sep}`);
    const projectDir = path_1.default.join(tmpdir, projectSpec.name);
    const templates = await (0, init_controller_1.fetchTemplates)();
    const projectPath = await (0, init_controller_1.cloneProjectTemplate)(tmpdir, projectSpec.name, templates[0]);
    await (0, init_controller_1.prepare)(projectPath, projectSpec);
    // Install dependencies
    child_process_1.default.execSync(`npm i`, { cwd: projectDir });
    await codegen_1.default.run(['-l', projectDir]);
    await build_1.default.run(['-f', projectDir]);
    return projectDir;
}
exports.createTestProject = createTestProject;
describe('Cli publish', () => {
    let projectDir;
    afterEach(async () => {
        try {
            await (0, util_1.promisify)(rimraf_1.default)(projectDir);
        }
        catch (e) {
            console.warn('Failed to clean up tmp dir after test');
        }
    });
    it('should not allow uploading a v0.0.1 spec version project', async () => {
        projectDir = await createTestProject(projectSpecV0_0_1);
        await expect((0, publish_controller_1.uploadToIpfs)('', ipfsEndpoint, projectDir)).rejects.toBeDefined();
    });
    it(`upload file to ipfs`, async () => {
        // only enable when test locally
        const ipfs = (0, ipfs_http_client_1.create)({ url: ipfsEndpoint });
        //test string
        const cid = await (0, publish_controller_1.uploadFile)('Test for upload string to ipfs', testAuth);
        console.log(`upload file cid: ${cid}`);
        // test fs stream (project)
        projectDir = await createTestProject(projectSpecV0_2_0);
        const fsStream = fs_1.default.createReadStream(path_1.default.resolve(projectDir, 'project.yaml'));
        const cid2 = await (0, publish_controller_1.uploadFile)(fsStream, testAuth);
        console.log(`upload file cid: ${cid2}`);
    });
    it('should upload appropriate project to IPFS', async () => {
        projectDir = await createTestProject(projectSpecV0_2_0);
        const cid = await (0, publish_controller_1.uploadToIpfs)(projectDir, testAuth);
        expect(cid).toBeDefined();
        // validation no longer required, as it is deployment object been published
        // await expect(Validate.run(['-l', cid, '--ipfs', ipfsEndpoint])).resolves.toBe(undefined);
    });
    it('upload project from a manifest', async () => {
        projectDir = await createTestProject(projectSpecV0_2_0);
        const manifestPath = path_1.default.resolve(projectDir, 'project.yaml');
        const testManifestPath = path_1.default.resolve(projectDir, 'test.yaml');
        fs_1.default.renameSync(manifestPath, testManifestPath);
        await publish_1.default.run(['-f', testManifestPath]);
    });
    it('should not allow uploading a v0.0.1 spec version project', async () => {
        projectDir = await createTestProject(projectSpecV0_0_1);
        await expect((0, publish_controller_1.uploadToIpfs)('', ipfsEndpoint, projectDir)).rejects.toBeDefined();
    });
    it('v1.0.0 should deploy', async () => {
        projectDir = await createTestProject(exports.projectSpecV1_0_0);
        const reader = await common_1.ReaderFactory.create(projectDir);
        const manifest = (0, common_substrate_1.parseSubstrateProjectManifest)(await reader.getProjectSchema()).asImpl;
        expect(manifest.runner).toBeDefined();
    });
    it('convert to deployment and removed descriptive field', async () => {
        projectDir = await createTestProject(exports.projectSpecV1_0_0);
        const reader = await common_1.ReaderFactory.create(projectDir);
        const manifest = (0, common_substrate_1.parseSubstrateProjectManifest)(await reader.getProjectSchema()).asImpl;
        const deployment = manifest.toDeployment();
        expect(deployment).not.toContain('author');
        expect(deployment).not.toContain('endpoint');
        expect(deployment).not.toContain('dictionary');
        expect(deployment).not.toContain('description');
        expect(deployment).not.toContain('repository');
        expect(deployment).toContain('chainId');
        expect(deployment).toContain('specVersion');
        expect(deployment).toContain('dataSources');
    });
});
//# sourceMappingURL=publish-controller.spec.js.map
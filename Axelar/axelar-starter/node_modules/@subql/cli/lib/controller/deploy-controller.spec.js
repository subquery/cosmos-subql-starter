"use strict";
// Copyright 2020-2022 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const deploy_controller_1 = require("./deploy-controller");
const project_controller_1 = require("./project-controller");
jest.setTimeout(120000);
const projectSpec = {
    org: process.env.SUBQL_ORG_TEST,
    projectName: 'mockedstarter',
    repository: 'https://github.com/bz888/test-deployment-2',
    ipfs: 'QmaVh8DGzuRCJZ5zYEDxXQsXYqP9HihjjeuxNNteSDq8xX',
    subtitle: '',
    description: '',
    logoURl: '',
    apiVersion: '2',
    type: 'stage',
};
async function deployTestProject(validator, ipfs, org, project_name, testAuth, url) {
    const indexerV = await (0, deploy_controller_1.imageVersions)(validator.manifestRunner.node.name, validator.manifestRunner.node.version, testAuth, url);
    const queryV = await (0, deploy_controller_1.imageVersions)(validator.manifestRunner.query.name, validator.manifestRunner.query.version, testAuth, url);
    const endpoint = await (0, deploy_controller_1.networkEndpoints)(url);
    const dictEndpoint = await (0, deploy_controller_1.dictionaryEndpoints)(url);
    return (0, deploy_controller_1.deployToHostedService)(org, project_name, testAuth, ipfs, indexerV[0], queryV[0], (0, deploy_controller_1.processEndpoints)(endpoint, validator.chainId), projectSpec.type, (0, deploy_controller_1.processEndpoints)(dictEndpoint, validator.chainId), {}, {}, url);
}
const describeIf = (condition, ...args) => condition ? describe(...args) : describe.skip(...args);
// Replace/Update your access token when test locally
const testAuth = process.env.SUBQL_ACCESS_TOKEN_TEST;
describeIf(!!testAuth, 'CLI deploy, delete, promote', () => {
    beforeAll(async () => {
        const { apiVersion, description, logoURl, org, projectName, repository, subtitle } = projectSpec;
        try {
            await (0, project_controller_1.createProject)(org, subtitle, logoURl, projectName, testAuth, repository, description, apiVersion, undefined, constants_1.ROOT_API_URL_DEV);
        }
        catch (e) {
            console.warn(`Failed at create project ${projectName} ${e}`);
        }
    });
    afterAll(async () => {
        try {
            await (0, project_controller_1.deleteProject)(testAuth, projectSpec.org, projectSpec.projectName, constants_1.ROOT_API_URL_DEV);
        }
        catch (e) {
            console.warn('Failed to delete project', e);
        }
    });
    it('Deploy to Hosted Service and Delete', async () => {
        const { ipfs, org, projectName } = projectSpec;
        const validator = await (0, deploy_controller_1.ipfsCID_validate)(ipfs, testAuth, constants_1.ROOT_API_URL_DEV);
        const deploy_output = await deployTestProject(validator, ipfs, org, projectName, testAuth, constants_1.ROOT_API_URL_DEV);
        const del_output = await (0, deploy_controller_1.deleteDeployment)(org, projectName, testAuth, deploy_output.id, constants_1.ROOT_API_URL_DEV);
        expect(typeof deploy_output.id).toBe('number');
        expect(+del_output).toBe(deploy_output.id);
    });
    // Only test locally
    it.skip('Promote Deployment', async () => {
        const { ipfs, org, projectName } = projectSpec;
        let status;
        let attempt = 0;
        const validator = await (0, deploy_controller_1.ipfsCID_validate)(ipfs, testAuth, constants_1.ROOT_API_URL_DEV);
        const deployOutput = await deployTestProject(validator, ipfs, org, projectName, testAuth, constants_1.ROOT_API_URL_DEV);
        while (status !== 'running') {
            if (attempt >= 5)
                break;
            attempt = attempt + 1;
            await (0, utils_1.delay)(30);
            status = await (0, deploy_controller_1.deploymentStatus)(org, projectName, testAuth, deployOutput.id, constants_1.ROOT_API_URL_DEV);
            if (status === 'running') {
                const promoteOutput = await (0, deploy_controller_1.promoteDeployment)(org, projectName, testAuth, deployOutput.id, constants_1.ROOT_API_URL_DEV);
                expect(+promoteOutput).toBe(deployOutput.id);
            }
        }
    });
    it('should return true for valid ipfsCID', async () => {
        const validator = await (0, deploy_controller_1.ipfsCID_validate)(projectSpec.ipfs, testAuth, constants_1.ROOT_API_URL_DEV);
        expect(validator.valid).toBe(true);
    });
    it('to throw error for invalid ipfsCID', async () => {
        try {
            await (0, deploy_controller_1.ipfsCID_validate)('fake', testAuth, constants_1.ROOT_API_URL_DEV);
        }
        catch (e) {
            expect(e.message).toBe('Failed to validate IPFS CID: fake is not a valid subquery deployment id!');
        }
    });
    it('get Endpoint - polkadot', async () => {
        const validator = await (0, deploy_controller_1.ipfsCID_validate)(projectSpec.ipfs, testAuth, constants_1.ROOT_API_URL_DEV);
        const endpoints = await (0, deploy_controller_1.networkEndpoints)(constants_1.ROOT_API_URL_DEV);
        expect((0, deploy_controller_1.processEndpoints)(endpoints, validator.chainId)).toBe('wss://polkadot.api.onfinality.io/public-ws');
    });
    it('get DictEndpoint - polkadot', async () => {
        const validator = await (0, deploy_controller_1.ipfsCID_validate)(projectSpec.ipfs, testAuth, constants_1.ROOT_API_URL_DEV);
        const dict = await (0, deploy_controller_1.dictionaryEndpoints)(constants_1.ROOT_API_URL_DEV);
        expect((0, deploy_controller_1.processEndpoints)(dict, validator.chainId)).toBe('https://api.subquery.network/sq/subquery/polkadot-dictionary');
    });
    it('reDeploy to Hosted Service', async () => {
        const { ipfs, org, projectName, type } = projectSpec;
        const newIPFS = 'QmbKvrzwSmzTZi5jrhEpa6yDDHQXRURi5S4ztLgJLpBxAi';
        const validator = await (0, deploy_controller_1.ipfsCID_validate)(projectSpec.ipfs, testAuth, constants_1.ROOT_API_URL_DEV);
        const deployOutput = await deployTestProject(validator, ipfs, org, projectName, testAuth, constants_1.ROOT_API_URL_DEV);
        const initProjectInfo = await (0, deploy_controller_1.projectsInfo)(testAuth, org, projectName, constants_1.ROOT_API_URL_DEV, type);
        const endpoints = await (0, deploy_controller_1.networkEndpoints)(constants_1.ROOT_API_URL_DEV);
        const dict = await (0, deploy_controller_1.dictionaryEndpoints)(constants_1.ROOT_API_URL_DEV);
        const indexerV = await (0, deploy_controller_1.imageVersions)(validator.manifestRunner.node.name, validator.manifestRunner.node.version, testAuth, constants_1.ROOT_API_URL_DEV);
        const queryV = await (0, deploy_controller_1.imageVersions)(validator.manifestRunner.query.name, validator.manifestRunner.query.version, testAuth, constants_1.ROOT_API_URL_DEV);
        await (0, deploy_controller_1.redeploy)(org, projectName, deployOutput.id, testAuth, newIPFS, (0, deploy_controller_1.processEndpoints)(endpoints, validator.chainId), (0, deploy_controller_1.processEndpoints)(dict, validator.chainId), indexerV[0], queryV[0], {}, {}, constants_1.ROOT_API_URL_DEV);
        const updatedInfo = await (0, deploy_controller_1.projectsInfo)(testAuth, org, projectName, constants_1.ROOT_API_URL_DEV, type);
        expect(updatedInfo.id).toBe(initProjectInfo.id);
        expect(updatedInfo.version).not.toEqual(deployOutput.version);
    });
});
//# sourceMappingURL=deploy-controller.spec.js.map
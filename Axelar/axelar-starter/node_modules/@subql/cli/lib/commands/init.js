"use strict";
// Copyright 2020-2022 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const url_1 = require("url");
const core_1 = require("@oclif/core");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const cli_ux_1 = tslib_1.__importDefault(require("cli-ux"));
const fuzzy_1 = tslib_1.__importDefault(require("fuzzy"));
const inquirer = tslib_1.__importStar(require("inquirer"));
const lodash_1 = require("lodash");
const init_controller_1 = require("../controller/init-controller");
inquirer.registerPrompt('autocomplete', require('inquirer-autocomplete-prompt'));
// Helper function for fuzzy search on prompt input
function filterInput(arr) {
    return (_, input) => {
        input = input || '';
        return new Promise((resolve) => {
            resolve(fuzzy_1.default.filter(input, arr).map((el) => {
                return el.original;
            }));
        });
    };
}
async function promptValidRemoteAndBranch() {
    let isValid = false;
    let remote;
    while (!isValid) {
        try {
            remote = await cli_ux_1.default.prompt('Custom template git remote', {
                required: true,
            });
            new url_1.URL(remote);
            isValid = true;
        }
        catch (e) {
            console.log(`Not a valid git remote URL: '${remote}', try again`);
            continue;
        }
    }
    const branch = await cli_ux_1.default.prompt('Custom template git branch', {
        required: true,
    });
    return [remote, branch];
}
//
class Init extends core_1.Command {
    async run() {
        const { args, flags } = await this.parse(Init);
        this.location = flags.location ? path_1.default.resolve(flags.location) : process.cwd();
        this.project = {};
        this.project.name = args.projectName
            ? args.projectName
            : await cli_ux_1.default.prompt('Project name', { default: 'subql-starter', required: true });
        if (fs_1.default.existsSync(path_1.default.join(this.location, `${this.project.name}`))) {
            throw new Error(`Directory ${this.project.name} exists, try another project name`);
        }
        let templates;
        let selectedTemplate;
        templates = await (0, init_controller_1.fetchTemplates)();
        await this.observeTemplates(templates, flags);
        //Family selection
        const families = (0, lodash_1.uniq)(templates.map(({ family }) => family)).sort();
        await inquirer
            .prompt([
            {
                name: 'familyResponse',
                message: 'Select a network family',
                type: 'autocomplete',
                searchText: '',
                emptyText: 'Network family not found',
                pageSize: 20,
                source: filterInput(families),
            },
        ])
            .then(({ familyResponse }) => {
            this.networkFamily = familyResponse;
        });
        templates = templates.filter(({ family }) => family === this.networkFamily);
        await this.observeTemplates(templates, flags);
        // Network selection
        const networks = (0, lodash_1.uniq)(templates.map(({ network }) => network)).sort();
        await inquirer
            .prompt([
            {
                name: 'networkResponse',
                message: 'Select a network',
                type: 'autocomplete',
                searchText: '',
                emptyText: 'Network not found',
                pageSize: 20,
                source: filterInput(networks),
            },
        ])
            .then(({ networkResponse }) => {
            this.network = networkResponse;
        });
        const candidateTemplates = templates.filter(({ network }) => network === this.network);
        await this.observeTemplates(candidateTemplates, flags);
        // Templates selection
        const paddingWidth = candidateTemplates.map(({ name }) => name.length).reduce((acc, xs) => Math.max(acc, xs)) + 5;
        const templateDisplays = candidateTemplates.map(({ description, name }) => `${name.padEnd(paddingWidth, ' ')}${chalk_1.default.gray(description)}`);
        templateDisplays.push(`${'Other'.padEnd(paddingWidth, ' ')}${chalk_1.default.gray('Enter a custom git endpoint')}`);
        await inquirer
            .prompt([
            {
                name: 'templateDisplay',
                message: 'Select a template project',
                type: 'autocomplete',
                searchText: '',
                emptyText: 'Template not found',
                source: filterInput(templateDisplays),
            },
        ])
            .then(async ({ templateDisplay }) => {
            const templateName = templateDisplay.split(' ')[0];
            if (templateName === 'Other') {
                await this.observeTemplates([], flags);
            }
            else {
                selectedTemplate = templates.find(({ name }) => name === templateName);
                await this.observeTemplates([selectedTemplate], flags);
            }
        });
        this.projectPath = await (0, init_controller_1.cloneProjectTemplate)(this.location, this.project.name, selectedTemplate);
        await this.setupProject(flags);
    }
    // observe templates, if no option left or manually select use custom templates
    async observeTemplates(templates, flags) {
        if (templates.length === 0) {
            const [gitRemote, gitBranch] = await promptValidRemoteAndBranch();
            this.projectPath = await (0, init_controller_1.cloneProjectGit)(this.location, this.project.name, gitRemote, gitBranch);
        }
    }
    async setupProject(flags) {
        const [defaultSpecVersion, defaultRepository, defaultEndpoint, defaultAuthor, defaultVersion, defaultDescription, defaultLicense,] = await (0, init_controller_1.readDefaults)(this.projectPath);
        // Should use template specVersion as default, otherwise use user provided
        flags.specVersion = defaultSpecVersion !== null && defaultSpecVersion !== void 0 ? defaultSpecVersion : flags.specVersion;
        this.project.endpoint = await cli_ux_1.default.prompt('RPC endpoint:', {
            default: defaultEndpoint !== null && defaultEndpoint !== void 0 ? defaultEndpoint : 'wss://polkadot.api.onfinality.io/public-ws',
            required: true,
        });
        this.project.repository = await cli_ux_1.default.prompt('Git repository', { required: false, default: defaultRepository });
        const descriptionHint = defaultDescription.substring(0, 40).concat('...');
        this.project.author = await cli_ux_1.default.prompt('Author', { required: true, default: defaultAuthor });
        this.project.description = await cli_ux_1.default
            .prompt('Description', {
            required: false,
            default: descriptionHint,
        })
            .then((description) => {
            return description === descriptionHint ? defaultDescription : description;
        });
        this.project.version = await cli_ux_1.default.prompt('Version', { required: true, default: defaultVersion });
        this.project.license = await cli_ux_1.default.prompt('License', { required: true, default: defaultLicense });
        cli_ux_1.default.action.start('Preparing project');
        await (0, init_controller_1.prepare)(this.projectPath, this.project);
        cli_ux_1.default.action.stop();
        if (flags['install-dependencies']) {
            cli_ux_1.default.action.start('Installing dependencies');
            (0, init_controller_1.installDependencies)(this.projectPath, flags.npm);
            cli_ux_1.default.action.stop();
        }
        this.log(`${this.project.name} is ready`);
        process.exit(0);
    }
}
exports.default = Init;
Init.description = 'Initialize a scaffold subquery project';
Init.flags = {
    force: core_1.Flags.boolean({ char: 'f' }),
    location: core_1.Flags.string({ char: 'l', description: 'local folder to create the project in' }),
    'install-dependencies': core_1.Flags.boolean({ description: 'Install dependencies as well', default: false }),
    npm: core_1.Flags.boolean({ description: 'Force using NPM instead of yarn, only works with `install-dependencies` flag' }),
};
Init.args = [
    {
        name: 'projectName',
        description: 'Give the starter project name',
    },
];
//# sourceMappingURL=init.js.map
"use strict";
// Copyright 2020-2022 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const path_1 = tslib_1.__importDefault(require("path"));
const core_1 = require("@oclif/core");
const common_1 = require("@subql/common");
const publish_controller_1 = require("../controller/publish-controller");
const build_1 = tslib_1.__importDefault(require("./build"));
const ACCESS_TOKEN_PATH = path_1.default.resolve(process.env.HOME, '.subql/SUBQL_ACCESS_TOKEN');
class Publish extends core_1.Command {
    async run() {
        var _a;
        const { flags } = await this.parse(Publish);
        const location = flags.location ? path_1.default.resolve(flags.location) : process.cwd();
        const project = (0, common_1.getProjectRootAndManifest)(location);
        // Ensure that the project is built
        try {
            await build_1.default.run(['--location', project.root, '-s']);
        }
        catch (e) {
            this.log(e);
            this.error('Failed to build project');
        }
        let authToken;
        if (process.env.SUBQL_ACCESS_TOKEN) {
            authToken = process.env.SUBQL_ACCESS_TOKEN;
        }
        else if ((0, fs_1.existsSync)(ACCESS_TOKEN_PATH)) {
            try {
                authToken = (_a = process.env.SUBQL_ACCESS_TOKEN) !== null && _a !== void 0 ? _a : (0, fs_1.readFileSync)(ACCESS_TOKEN_PATH, 'utf8');
            }
            catch (e) {
                throw new Error(`Failed to read SUBQL_ACCESS_TOKEN from ${ACCESS_TOKEN_PATH}: ${e}`);
            }
        }
        else {
            throw new Error('Please provide SUBQL_ACCESS_TOKEN before publish');
        }
        const cid = await (0, publish_controller_1.uploadToIpfs)(project.manifest, authToken.trim(), flags.ipfs).catch((e) => this.error(e));
        await (0, publish_controller_1.createIPFSFile)(location, cid);
        if (!flags.output) {
            this.log('Uploading SubQuery project to IPFS');
            this.log(`SubQuery Project uploaded to IPFS: ${cid}`);
        }
        else {
            this.log(`${cid}`);
        }
    }
}
exports.default = Publish;
Publish.description = 'Upload this SubQuery project to IPFS';
Publish.flags = {
    location: core_1.Flags.string({ char: 'f', description: 'from project or manifest path' }),
    ipfs: core_1.Flags.string({ description: 'IPFS gateway endpoint', required: false }),
    output: core_1.Flags.boolean({ char: 'o', description: 'Output IPFS CID', required: false }),
};
//# sourceMappingURL=publish.js.map
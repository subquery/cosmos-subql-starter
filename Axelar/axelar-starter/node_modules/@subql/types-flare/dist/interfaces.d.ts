import { EthereumBlock, EthereumBlockWrapper, EthereumLog, EthereumLogFilter, EthereumTransaction, EthereumTransactionFilter } from './ethereum';
export interface Entity {
    id: string;
}
export declare type FunctionPropertyNames<T> = {
    [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T];
export interface Store {
    get(entity: string, id: string): Promise<Entity | null>;
    getByField(entity: string, field: string, value: any): Promise<Entity[]>;
    getOneByField(entity: string, field: string, value: any): Promise<Entity | null>;
    set(entity: string, id: string, data: Entity): Promise<void>;
    bulkCreate(entity: string, data: Entity[]): Promise<void>;
    remove(entity: string, id: string): Promise<void>;
}
export interface BlockWrapper<B extends EthereumBlock = EthereumBlock, C extends EthereumTransaction = EthereumTransaction, E extends EthereumLog = EthereumLog, CF extends EthereumTransactionFilter = EthereumTransactionFilter, EF extends EthereumLogFilter = EthereumLogFilter> {
    block: B;
    blockHeight: number;
    specVersion?: number;
    hash: string;
    calls?: (filters?: CF | CF[], ds?: any) => C[];
    transactions?: C[];
    events?: (filters?: EF | EF[], ds?: any) => E[];
    logs?: E[];
}
export interface ApiWrapper<BW extends BlockWrapper = EthereumBlockWrapper> {
    init: () => Promise<void>;
    getGenesisHash: () => string;
    getRuntimeChain: () => string;
    getSpecName: () => string;
    getFinalizedBlockHeight: () => Promise<number>;
    getLastHeight: () => Promise<number>;
    fetchBlocks: (bufferBlocks: number[]) => Promise<BW[]>;
    freezeApi: (processor: any, blockContent?: BlockWrapper) => void;
}
export declare type DynamicDatasourceCreator = (name: string, args: Record<string, unknown>) => Promise<void>;

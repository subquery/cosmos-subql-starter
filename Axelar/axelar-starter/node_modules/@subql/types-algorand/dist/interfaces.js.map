{"version":3,"file":"interfaces.js","sourceRoot":"","sources":["../src/interfaces.ts"],"names":[],"mappings":";AAAA,gEAAgE;AAChE,sCAAsC;;;AAyBtC,IAAY,aAOX;AAPD,WAAY,aAAa;IACvB,8BAAa,CAAA;IACb,gCAAe,CAAA;IACf,sCAAqB,CAAA;IACrB,gCAAe,CAAA;IACf,kCAAiB,CAAA;IACjB,kCAAiB,CAAA;AACnB,CAAC,EAPW,aAAa,GAAb,qBAAa,KAAb,qBAAa,QAOxB","sourcesContent":["// Copyright 2020-2022 OnFinality Limited authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport type {TransactionType, Indexer} from 'algosdk';\n\nexport interface Entity {\n  id: string;\n}\n\nexport type FunctionPropertyNames<T> = {\n  [K in keyof T]: T[K] extends Function ? K : never;\n}[keyof T];\n\nexport interface Store {\n  get(entity: string, id: string): Promise<Entity | null>;\n  getByField(entity: string, field: string, value: any, options?: {offset?: number; limit?: number}): Promise<Entity[]>;\n  getOneByField(entity: string, field: string, value: any): Promise<Entity | null>;\n  set(entity: string, id: string, data: Entity): Promise<void>;\n  bulkCreate(entity: string, data: Entity[]): Promise<void>;\n  //if fields in provided, only specify fields will be updated\n  bulkUpdate(entity: string, data: Entity[], fields?: string[]): Promise<void>;\n  remove(entity: string, id: string): Promise<void>;\n}\n\nexport type DynamicDatasourceCreator = (name: string, args: Record<string, unknown>) => Promise<void>;\n\nexport enum EOnCompletion {\n  noop = 'noop',\n  optin = 'optin',\n  closeout = 'closeout',\n  clear = 'clear',\n  update = 'update',\n  delete = 'delete',\n}\n\nexport interface BlockReward {\n  feeSink: string;\n  rewardsCalculationRound: number;\n  rewardsLevel: number;\n  rewardsPool: string;\n  rewardsRate: string;\n  rewardsResidue: number;\n}\n\nexport interface StateSchema {\n  numByteSlice: number;\n  numUint: number;\n}\n\nexport interface EvalDelta {\n  action: number;\n  bytes?: string;\n  uint?: number;\n}\n\nexport interface EvalDeltaKeyValue {\n  key: string;\n  value: EvalDelta;\n}\n\nexport interface TransactionAssetParam {\n  clawback?: string;\n  creator: string;\n  decimals: number;\n  defaultFrozen?: boolean;\n  freeze?: string;\n  manager?: string;\n  metadataHash?: string;\n  name?: string;\n  nameB64?: string;\n  reserve?: string;\n  total: number;\n  unitName?: string;\n  unitNameB64?: string;\n  url?: string;\n  urlB64?: string;\n}\n\nexport interface TransactionApplication {\n  accounts?: string[];\n  applicationArgs?: string[];\n  applicationId: number;\n  approvalProgram?: string;\n  clearStateProgram?: string;\n  extraProgramPages?: number;\n  foreignApps?: number[];\n  foreignAssets?: number[];\n  globalStateSchema?: StateSchema;\n  localStateSchema?: StateSchema;\n  onCompletion: EOnCompletion;\n}\n\nexport interface TransactionAssetConfig {\n  assetId?: number;\n  params?: TransactionAssetParam;\n}\n\nexport interface TransactionAssetFreeze {\n  address: string;\n  assetId: number;\n  newFreezeStatus: boolean;\n}\n\nexport interface TransactionAssetTransfer {\n  amount: number;\n  assetId: number;\n  closeAmount?: number;\n  closeTo?: string;\n  receiver: string;\n  sender?: string;\n}\n\nexport interface TransactionKeyreg {\n  nonParticipation?: boolean;\n  selectionParticipationKey?: string;\n  stateProofKey?: string;\n  voteFirstValid?: number;\n  voteKeyDilution?: number;\n  voteLastValid?: number;\n  voteParticipationKey?: string;\n}\n\nexport interface TransactionPayment {\n  amount: number;\n  closeAmount?: number;\n  closeRemainderTo?: string;\n  receiver: string;\n}\n\nexport interface TransactionSignatureMultisigSubsignature {\n  publicKey?: string;\n  signature?: string;\n}\n\nexport interface TransactionSignatureMultisig {\n  subsignature?: TransactionSignatureMultisigSubsignature[];\n  threshold?: number;\n  version?: number;\n}\n\nexport interface TransactionSignatureLogicsig {\n  args?: string[];\n  logic: string;\n  multisigSignature?: TransactionSignatureMultisig;\n  signature?: string;\n}\n\nexport interface TransactionSignature {\n  logicsig?: TransactionSignatureLogicsig;\n  multisig?: TransactionSignatureMultisig;\n  sig?: string;\n}\n\nexport interface BlockUpgradeState {\n  currentProtocol: string;\n  nextProtocol?: string;\n  nextProtocolApprovals?: number;\n  nextProtocolSwitchOn?: number;\n  nextProtocolVoteBefore?: number;\n}\n\nexport interface BlockUpgradeVote {\n  upgradeApprove?: boolean;\n  upgradeDelay?: number;\n  upgradePropose?: string;\n}\n\nexport interface AlgorandTransaction {\n  applicationTransaction?: TransactionApplication;\n  assetConfigTransaction?: TransactionAssetConfig;\n  assetFreezeTransaction?: TransactionAssetFreeze;\n  assetTransferTransaction?: TransactionAssetTransfer;\n  authAddr?: string;\n  closeRewards?: number;\n  closingAmount?: number;\n  confirmedRound?: number;\n  createdApplicationIndex?: number;\n  createdAssetIndex?: number;\n  fee: number;\n  firstValid: number;\n  genesisHash?: string;\n  genesisId?: string;\n  globalStateDelta?: EvalDeltaKeyValue[];\n  group?: string;\n  id?: string;\n  innerTxns?: AlgorandTransaction[];\n  intraRoundOffset?: number;\n  keyregTransaction?: TransactionKeyreg;\n  lastValid: number;\n  lease?: string;\n  localStateDelta?: string[];\n  logs?: string[];\n  note?: string;\n  paymentTransaction?: TransactionPayment;\n  receiverRewards?: number;\n  rekeyTo?: string;\n  roundTime?: number;\n  sender: string;\n  senderRewards?: number;\n  signature?: TransactionSignature;\n  txType: TransactionType;\n}\n\nexport interface AlgorandBlock {\n  hash: string;\n  genesisHash: string;\n  genesisId: string;\n  previousBlockHash: string;\n  rewards?: BlockReward[];\n  round: number;\n  seed: string;\n  timestamp: number;\n  transactions?: AlgorandTransaction[];\n  transactionsRoot: string;\n  txnCounter?: number;\n  upgradeState?: BlockUpgradeState;\n  upgradeVote?: BlockUpgradeVote;\n}\n\nexport type SafeAPI = {\n  indexer: Indexer;\n  getBlock(): Promise<AlgorandBlock>;\n  getTxns(): Promise<AlgorandTransaction[]>;\n};\n"]}
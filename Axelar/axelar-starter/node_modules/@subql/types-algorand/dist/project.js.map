{"version":3,"file":"project.js","sourceRoot":"","sources":["../src/project.ts"],"names":[],"mappings":";AAAA,gEAAgE;AAChE,sCAAsC;;;AAKtC,IAAY,sBAEX;AAFD,WAAY,sBAAsB;IAChC,sDAA4B,CAAA;AAC9B,CAAC,EAFW,sBAAsB,GAAtB,8BAAsB,KAAtB,8BAAsB,QAEjC;AAED,IAAY,mBAGX;AAHD,WAAY,mBAAmB;IAC7B,sDAA+B,CAAA;IAC/B,kEAA2C,CAAA;AAC7C,CAAC,EAHW,mBAAmB,GAAnB,2BAAmB,KAAnB,2BAAmB,QAG9B","sourcesContent":["// Copyright 2020-2022 OnFinality Limited authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport type {Indexer} from 'algosdk';\nimport {AlgorandBlock, AlgorandTransaction} from './interfaces';\n\nexport enum AlgorandDataSourceKind {\n  Runtime = 'algorand/Runtime',\n}\n\nexport enum AlgorandHandlerKind {\n  Block = 'algorand/BlockHandler',\n  Transaction = 'algorand/TransactionHandler',\n}\n\nexport type RuntimeHandlerInputMap = {\n  [AlgorandHandlerKind.Block]: AlgorandBlock;\n  [AlgorandHandlerKind.Transaction]: AlgorandTransaction;\n};\n\ntype RuntimeFilterMap = {\n  [AlgorandHandlerKind.Block]: {};\n  [AlgorandHandlerKind.Transaction]: AlgorandTransactionFilter;\n};\n\nexport interface ProjectManifest {\n  specVersion: string;\n  description: string;\n  repository: string;\n\n  schema: string;\n\n  network: {\n    endpoint: string;\n  };\n\n  dataSources: AlgorandDataSource[];\n}\n\n// [startSpecVersion?, endSpecVersion?] closed range\nexport type SpecVersionRange = [number, number];\n\ninterface AlgorandBaseHandlerFilter {\n  specVersion?: SpecVersionRange;\n}\n\nexport interface AlgorandBlockFilter extends AlgorandBaseHandlerFilter {\n  modulo?: number;\n  timestamp?: string;\n}\n\nexport interface AlgorandTransactionFilter {\n  txType?: string;\n  sender?: string;\n  receiver?: string;\n  nonParticipant?: boolean;\n  assetId?: number;\n  newFreezeStatus?: boolean;\n  address?: string;\n  applicationId?: number;\n}\n\nexport type AlgorandBlockHandler = AlgorandCustomHandler<AlgorandHandlerKind.Block, AlgorandBlockFilter>;\nexport type AlgorandTransactionHandler = AlgorandCustomHandler<\n  AlgorandHandlerKind.Transaction,\n  AlgorandTransactionFilter\n>;\n\nexport interface AlgorandCustomHandler<K extends string = string, F = Record<string, unknown>> {\n  handler: string;\n  kind: K;\n  filter?: F;\n}\n\nexport type AlgorandRuntimeHandler = AlgorandBlockHandler | AlgorandTransactionHandler;\nexport type AlgorandHandler = AlgorandRuntimeHandler | AlgorandCustomHandler<string, unknown>;\nexport type AlgorandRuntimeHandlerFilter = AlgorandBlockFilter | AlgorandTransactionFilter;\n\nexport interface AlgorandMapping<T extends AlgorandHandler = AlgorandHandler> extends FileReference {\n  handlers: T[];\n}\n\ninterface IAlgorandDataSource<M extends AlgorandMapping> {\n  name?: string;\n  kind: string;\n  startBlock?: number;\n  mapping: M;\n}\n\nexport interface AlgorandRuntimeDataSource<\n  M extends AlgorandMapping<AlgorandRuntimeHandler> = AlgorandMapping<AlgorandRuntimeHandler>\n> extends IAlgorandDataSource<M> {\n  kind: AlgorandDataSourceKind.Runtime;\n}\n\nexport type AlgorandDataSource = AlgorandRuntimeDataSource | AlgorandCustomDataSource;\n\nexport interface FileReference {\n  file: string;\n}\n\nexport type CustomDataSourceAsset = FileReference;\n\nexport type Processor<O = any> = FileReference & {options?: O};\n\nexport interface AlgorandCustomDataSource<\n  K extends string = string,\n  M extends AlgorandMapping = AlgorandMapping<AlgorandCustomHandler>,\n  O = any\n> extends IAlgorandDataSource<M> {\n  kind: K;\n  assets: Map<string, CustomDataSourceAsset>;\n  processor: Processor<O>;\n}\n\n//export type SubstrateBuiltinDataSource = IAlgorandDataSource;\n\nexport interface HandlerInputTransformer_0_0_0<\n  T extends AlgorandHandlerKind,\n  E,\n  DS extends AlgorandCustomDataSource = AlgorandCustomDataSource\n> {\n  (input: RuntimeHandlerInputMap[T], ds: DS, api: Indexer, assets?: Record<string, string>): Promise<E>; //  | SubstrateBuiltinDataSource\n}\n\nexport interface HandlerInputTransformer_1_0_0<\n  T extends AlgorandHandlerKind,\n  F,\n  E,\n  DS extends AlgorandCustomDataSource = AlgorandCustomDataSource\n> {\n  (params: {\n    input: RuntimeHandlerInputMap[T];\n    ds: DS;\n    filter?: F;\n    api: Indexer;\n    assets?: Record<string, string>;\n  }): Promise<E[]>; //  | SubstrateBuiltinDataSource\n}\n\ntype SecondLayerHandlerProcessorArray<\n  K extends string,\n  T,\n  DS extends AlgorandCustomDataSource<K> = AlgorandCustomDataSource<K>\n> = SecondLayerHandlerProcessor<AlgorandHandlerKind, T, DS>;\n\nexport interface AlgorandDataSourceProcessor<\n  K extends string,\n  DS extends AlgorandCustomDataSource<K> = AlgorandCustomDataSource<K>,\n  P extends Record<string, SecondLayerHandlerProcessorArray<K, any, DS>> = Record<\n    string,\n    SecondLayerHandlerProcessorArray<K, any, DS>\n  >\n> {\n  kind: K;\n  validate(ds: DS, assets: Record<string, string>): void;\n  dsFilterProcessor(ds: DS, api: Indexer): boolean;\n  handlerProcessors: P;\n}\n\nexport interface DictionaryQueryCondition {\n  field: string;\n  value: string;\n  matcher?: string; // defaults to \"equalTo\", use \"contains\" for JSON\n}\n\nexport interface DictionaryQueryEntry {\n  entity: string;\n  conditions: DictionaryQueryCondition[];\n}\n\ninterface SecondLayerHandlerProcessorBase<\n  K extends AlgorandHandlerKind,\n  F,\n  DS extends AlgorandCustomDataSource = AlgorandCustomDataSource\n> {\n  baseHandlerKind: K;\n  baseFilter: RuntimeFilterMap[K] | RuntimeFilterMap[K][];\n  filterValidator: (filter?: F) => void;\n  dictionaryQuery?: (filter: F, ds: DS) => DictionaryQueryEntry | undefined;\n}\n\n// only allow one custom handler for each baseHandler kind\nexport interface SecondLayerHandlerProcessor_0_0_0<\n  K extends AlgorandHandlerKind,\n  F,\n  E,\n  DS extends AlgorandCustomDataSource = AlgorandCustomDataSource\n> extends SecondLayerHandlerProcessorBase<K, F, DS> {\n  specVersion: undefined;\n  transformer: HandlerInputTransformer_0_0_0<K, E, DS>;\n  filterProcessor: (filter: F | undefined, input: RuntimeHandlerInputMap[K], ds: DS) => boolean;\n}\n\nexport interface SecondLayerHandlerProcessor_1_0_0<\n  K extends AlgorandHandlerKind,\n  F,\n  E,\n  DS extends AlgorandCustomDataSource = AlgorandCustomDataSource\n> extends SecondLayerHandlerProcessorBase<K, F, DS> {\n  specVersion: '1.0.0';\n  transformer: HandlerInputTransformer_1_0_0<K, F, E, DS>;\n  filterProcessor: (params: {filter: F | undefined; input: RuntimeHandlerInputMap[K]; ds: DS}) => boolean;\n}\n\nexport type SecondLayerHandlerProcessor<\n  K extends AlgorandHandlerKind,\n  F,\n  E,\n  DS extends AlgorandCustomDataSource = AlgorandCustomDataSource\n> = SecondLayerHandlerProcessor_0_0_0<K, F, E, DS> | SecondLayerHandlerProcessor_1_0_0<K, F, E, DS>;\n"]}
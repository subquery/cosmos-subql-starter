import { RegistryTypes } from '@polkadot/types/types';
import { EthereumBlock, EthereumBlockFilter, EthereumLog, EthereumLogFilter, EthereumTransaction, EthereumTransactionFilter } from './ethereum';
import { ApiWrapper } from './interfaces';
export declare enum EthereumDatasourceKind {
    Runtime = "ethereum/Runtime"
}
export declare enum EthereumHandlerKind {
    Block = "ethereum/BlockHandler",
    Call = "ethereum/TransactionHandler",
    Event = "ethereum/LogHandler"
}
export declare type EthereumRuntimeHandlerInputMap = {
    [EthereumHandlerKind.Block]: EthereumBlock;
    [EthereumHandlerKind.Call]: EthereumTransaction;
    [EthereumHandlerKind.Event]: EthereumLog;
};
declare type EthereumRuntimeFilterMap = {
    [EthereumHandlerKind.Block]: EthereumBlockFilter;
    [EthereumHandlerKind.Event]: EthereumLogFilter;
    [EthereumHandlerKind.Call]: EthereumTransactionFilter;
};
export interface ProjectManifest {
    specVersion: string;
    description: string;
    repository: string;
    schema: string;
    network: {
        endpoint: string;
        customTypes?: RegistryTypes;
    };
    dataSources: SubqlDatasource[];
}
export interface SubqlBlockHandler {
    handler: string;
    kind: EthereumHandlerKind.Block;
    filter?: EthereumBlockFilter;
}
export interface SubqlCallHandler {
    handler: string;
    kind: EthereumHandlerKind.Call;
    filter?: EthereumTransactionFilter;
}
export interface SubqlEventHandler {
    handler: string;
    kind: EthereumHandlerKind.Event;
    filter?: EthereumLogFilter;
}
export interface SubqlCustomHandler<K extends string = string, F = Record<string, unknown>> {
    handler: string;
    kind: K;
    filter?: F;
}
export declare type SubqlRuntimeHandler = SubqlBlockHandler | SubqlCallHandler | SubqlEventHandler;
export declare type SubqlHandler = SubqlRuntimeHandler | SubqlCustomHandler<string, unknown>;
export declare type SubqlHandlerFilter = EthereumBlockFilter | EthereumTransactionFilter | EthereumLogFilter;
export interface SubqlMapping<T extends SubqlHandler = SubqlHandler> {
    file: string;
    handlers: T[];
}
interface ISubqlDatasource<M extends SubqlMapping> {
    name?: string;
    kind: string;
    startBlock?: number;
    mapping: M;
}
export interface SubqlRuntimeDatasource<M extends SubqlMapping<SubqlRuntimeHandler> = SubqlMapping<SubqlRuntimeHandler>> extends ISubqlDatasource<M> {
    kind: EthereumDatasourceKind.Runtime;
    options?: any;
    assets?: Map<string, {
        file: string;
    }>;
}
export interface SubqlNetworkFilter {
    specName?: string;
}
export declare type SubqlDatasource = SubqlRuntimeDatasource | SubqlCustomDatasource;
export interface FileReference {
    file: string;
}
export declare type CustomDataSourceAsset = FileReference;
export declare type Processor<O = any> = FileReference & {
    options?: O;
};
export interface SubqlCustomDatasource<K extends string = string, M extends SubqlMapping = SubqlMapping<SubqlCustomHandler>, O = any> extends ISubqlDatasource<M> {
    kind: K;
    assets: Map<string, CustomDataSourceAsset>;
    processor: Processor<O>;
}
export interface HandlerInputTransformer_0_0_0<T extends EthereumHandlerKind, E, DS extends SubqlCustomDatasource = SubqlCustomDatasource> {
    (input: EthereumRuntimeHandlerInputMap[T], ds: DS, api: ApiWrapper, assets?: Record<string, string>): Promise<E>;
}
export interface HandlerInputTransformer_1_0_0<T extends EthereumHandlerKind, F, E, DS extends SubqlCustomDatasource = SubqlCustomDatasource> {
    (params: {
        input: EthereumRuntimeHandlerInputMap[T];
        ds: DS;
        filter?: F;
        api: ApiWrapper;
        assets?: Record<string, string>;
    }): Promise<E[]>;
}
export interface DictionaryQueryCondition {
    field: string;
    value: string;
}
export interface DictionaryQueryEntry {
    entity: string;
    conditions: DictionaryQueryCondition[];
}
export declare type SecondLayerHandlerProcessorArray<K extends string, F, T, DS extends SubqlCustomDatasource<K> = SubqlCustomDatasource<K>> = SecondLayerHandlerProcessor<EthereumHandlerKind.Block, F, T, DS> | SecondLayerHandlerProcessor<EthereumHandlerKind.Call, F, T, DS> | SecondLayerHandlerProcessor<EthereumHandlerKind.Event, F, T, DS>;
export interface SubqlDatasourceProcessor<K extends string, F, DS extends SubqlCustomDatasource<K> = SubqlCustomDatasource<K>, P extends Record<string, SecondLayerHandlerProcessorArray<K, F, any, DS>> = Record<string, SecondLayerHandlerProcessorArray<K, F, any, DS>>> {
    kind: K;
    validate(ds: DS, assets: Record<string, string>): void;
    dsFilterProcessor(ds: DS, api: ApiWrapper): boolean;
    handlerProcessors: P;
}
interface SecondLayerHandlerProcessorBase<K extends EthereumHandlerKind, F, DS extends SubqlCustomDatasource = SubqlCustomDatasource> {
    baseHandlerKind: K;
    baseFilter: EthereumRuntimeFilterMap[K] | EthereumRuntimeFilterMap[K][];
    filterValidator: (filter?: F) => void;
    dictionaryQuery?: (filter: F, ds: DS) => DictionaryQueryEntry | undefined;
}
export interface SecondLayerHandlerProcessor_0_0_0<K extends EthereumHandlerKind, F, E, DS extends SubqlCustomDatasource = SubqlCustomDatasource> extends SecondLayerHandlerProcessorBase<K, F, DS> {
    specVersion: undefined;
    transformer: HandlerInputTransformer_0_0_0<K, E, DS>;
    filterProcessor: (filter: F | undefined, input: EthereumRuntimeHandlerInputMap[K], ds: DS) => boolean;
}
export interface SecondLayerHandlerProcessor_1_0_0<K extends EthereumHandlerKind, F, E, DS extends SubqlCustomDatasource = SubqlCustomDatasource> extends SecondLayerHandlerProcessorBase<K, F, DS> {
    specVersion: '1.0.0';
    transformer: HandlerInputTransformer_1_0_0<K, F, E, DS>;
    filterProcessor: (params: {
        filter: F | undefined;
        input: EthereumRuntimeHandlerInputMap[K];
        ds: DS;
    }) => boolean;
}
export declare type SecondLayerHandlerProcessor<K extends EthereumHandlerKind, F, E, DS extends SubqlCustomDatasource = SubqlCustomDatasource> = SecondLayerHandlerProcessor_0_0_0<K, F, E, DS> | SecondLayerHandlerProcessor_1_0_0<K, F, E, DS>;
export {};

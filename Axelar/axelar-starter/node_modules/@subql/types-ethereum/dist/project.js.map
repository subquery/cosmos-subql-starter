{"version":3,"file":"project.js","sourceRoot":"","sources":["../src/project.ts"],"names":[],"mappings":";AAAA,gEAAgE;AAChE,sCAAsC;;;AAatC,IAAY,sBAEX;AAFD,WAAY,sBAAsB;IAChC,sDAA4B,CAAA;AAC9B,CAAC,EAFW,sBAAsB,GAAtB,8BAAsB,KAAtB,8BAAsB,QAEjC;AAED,IAAY,mBAIX;AAJD,WAAY,mBAAmB;IAC7B,sDAA+B,CAAA;IAC/B,2DAAoC,CAAA;IACpC,oDAA6B,CAAA;AAC/B,CAAC,EAJW,mBAAmB,GAAnB,2BAAmB,KAAnB,2BAAmB,QAI9B","sourcesContent":["// Copyright 2020-2022 OnFinality Limited authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport {RegistryTypes} from '@polkadot/types/types';\nimport {\n  EthereumBlock,\n  EthereumBlockFilter,\n  EthereumLog,\n  EthereumLogFilter,\n  EthereumTransaction,\n  EthereumTransactionFilter,\n} from './ethereum';\nimport {ApiWrapper} from './interfaces';\n\nexport enum EthereumDatasourceKind {\n  Runtime = 'ethereum/Runtime',\n}\n\nexport enum EthereumHandlerKind {\n  Block = 'ethereum/BlockHandler',\n  Call = 'ethereum/TransactionHandler',\n  Event = 'ethereum/LogHandler',\n}\n\nexport type EthereumRuntimeHandlerInputMap = {\n  [EthereumHandlerKind.Block]: EthereumBlock;\n  [EthereumHandlerKind.Call]: EthereumTransaction;\n  [EthereumHandlerKind.Event]: EthereumLog;\n};\n\ntype EthereumRuntimeFilterMap = {\n  [EthereumHandlerKind.Block]: EthereumBlockFilter;\n  [EthereumHandlerKind.Event]: EthereumLogFilter;\n  [EthereumHandlerKind.Call]: EthereumTransactionFilter;\n};\n\nexport interface ProjectManifest {\n  specVersion: string;\n  description: string;\n  repository: string;\n\n  schema: string;\n\n  network: {\n    endpoint: string;\n    customTypes?: RegistryTypes;\n  };\n\n  dataSources: SubqlDatasource[];\n}\n\nexport interface SubqlBlockHandler {\n  handler: string;\n  kind: EthereumHandlerKind.Block;\n  filter?: EthereumBlockFilter;\n}\n\nexport interface SubqlCallHandler {\n  handler: string;\n  kind: EthereumHandlerKind.Call;\n  filter?: EthereumTransactionFilter;\n}\n\nexport interface SubqlEventHandler {\n  handler: string;\n  kind: EthereumHandlerKind.Event;\n  filter?: EthereumLogFilter;\n}\n\nexport interface SubqlCustomHandler<K extends string = string, F = Record<string, unknown>> {\n  handler: string;\n  kind: K;\n  filter?: F;\n}\n\nexport type SubqlRuntimeHandler = SubqlBlockHandler | SubqlCallHandler | SubqlEventHandler;\n\nexport type SubqlHandler = SubqlRuntimeHandler | SubqlCustomHandler<string, unknown>;\n\nexport type SubqlHandlerFilter = EthereumBlockFilter | EthereumTransactionFilter | EthereumLogFilter;\n\nexport interface SubqlMapping<T extends SubqlHandler = SubqlHandler> {\n  file: string;\n  handlers: T[];\n}\n\ninterface ISubqlDatasource<M extends SubqlMapping> {\n  name?: string;\n  kind: string;\n  startBlock?: number;\n  mapping: M;\n}\n\nexport interface SubqlRuntimeDatasource<M extends SubqlMapping<SubqlRuntimeHandler> = SubqlMapping<SubqlRuntimeHandler>>\n  extends ISubqlDatasource<M> {\n  kind: EthereumDatasourceKind.Runtime;\n  options?: any;\n  assets?: Map<string, {file: string}>;\n}\n\nexport interface SubqlNetworkFilter {\n  specName?: string;\n}\n\nexport type SubqlDatasource = SubqlRuntimeDatasource | SubqlCustomDatasource; // | SubqlBuiltinDataSource;\n\nexport interface FileReference {\n  file: string;\n}\n\nexport type CustomDataSourceAsset = FileReference;\n\nexport type Processor<O = any> = FileReference & {options?: O};\n\nexport interface SubqlCustomDatasource<\n  K extends string = string,\n  M extends SubqlMapping = SubqlMapping<SubqlCustomHandler>,\n  O = any\n> extends ISubqlDatasource<M> {\n  kind: K;\n  assets: Map<string, CustomDataSourceAsset>;\n  processor: Processor<O>;\n}\n\n//export type SubqlBuiltinDataSource = ISubqlDatasource;\n\nexport interface HandlerInputTransformer_0_0_0<\n  T extends EthereumHandlerKind,\n  E,\n  DS extends SubqlCustomDatasource = SubqlCustomDatasource\n> {\n  (input: EthereumRuntimeHandlerInputMap[T], ds: DS, api: ApiWrapper, assets?: Record<string, string>): Promise<E>; //  | SubstrateBuiltinDataSource\n}\n\nexport interface HandlerInputTransformer_1_0_0<\n  T extends EthereumHandlerKind,\n  F,\n  E,\n  DS extends SubqlCustomDatasource = SubqlCustomDatasource\n> {\n  (params: {\n    input: EthereumRuntimeHandlerInputMap[T];\n    ds: DS;\n    filter?: F;\n    api: ApiWrapper;\n    assets?: Record<string, string>;\n  }): Promise<E[]>; //  | SubstrateBuiltinDataSource\n}\n\nexport interface DictionaryQueryCondition {\n  field: string;\n  value: string;\n}\n\nexport interface DictionaryQueryEntry {\n  entity: string;\n  conditions: DictionaryQueryCondition[];\n}\n\nexport type SecondLayerHandlerProcessorArray<\n  K extends string,\n  F,\n  T,\n  DS extends SubqlCustomDatasource<K> = SubqlCustomDatasource<K>\n> =\n  | SecondLayerHandlerProcessor<EthereumHandlerKind.Block, F, T, DS>\n  | SecondLayerHandlerProcessor<EthereumHandlerKind.Call, F, T, DS>\n  | SecondLayerHandlerProcessor<EthereumHandlerKind.Event, F, T, DS>;\n\nexport interface SubqlDatasourceProcessor<\n  K extends string,\n  F,\n  DS extends SubqlCustomDatasource<K> = SubqlCustomDatasource<K>,\n  P extends Record<string, SecondLayerHandlerProcessorArray<K, F, any, DS>> = Record<\n    string,\n    SecondLayerHandlerProcessorArray<K, F, any, DS>\n  >\n> {\n  kind: K;\n  validate(ds: DS, assets: Record<string, string>): void;\n  dsFilterProcessor(ds: DS, api: ApiWrapper): boolean;\n  handlerProcessors: P;\n}\n\n// export interface DictionaryQueryCondition {\n//   field: string;\n//   value: string;\n//   matcher?: string; // defaults to \"equalTo\", use \"contains\" for JSON\n// }\n\n// export interface DictionaryQueryEntry {\n//   entity: string;\n//   conditions: DictionaryQueryCondition[];\n// }\n\ninterface SecondLayerHandlerProcessorBase<\n  K extends EthereumHandlerKind,\n  F,\n  DS extends SubqlCustomDatasource = SubqlCustomDatasource\n> {\n  baseHandlerKind: K;\n  baseFilter: EthereumRuntimeFilterMap[K] | EthereumRuntimeFilterMap[K][];\n  filterValidator: (filter?: F) => void;\n  dictionaryQuery?: (filter: F, ds: DS) => DictionaryQueryEntry | undefined;\n}\n\nexport interface SecondLayerHandlerProcessor_0_0_0<\n  K extends EthereumHandlerKind,\n  F,\n  E,\n  DS extends SubqlCustomDatasource = SubqlCustomDatasource\n> extends SecondLayerHandlerProcessorBase<K, F, DS> {\n  specVersion: undefined;\n  transformer: HandlerInputTransformer_0_0_0<K, E, DS>;\n  filterProcessor: (filter: F | undefined, input: EthereumRuntimeHandlerInputMap[K], ds: DS) => boolean;\n}\n\nexport interface SecondLayerHandlerProcessor_1_0_0<\n  K extends EthereumHandlerKind,\n  F,\n  E,\n  DS extends SubqlCustomDatasource = SubqlCustomDatasource\n> extends SecondLayerHandlerProcessorBase<K, F, DS> {\n  specVersion: '1.0.0';\n  transformer: HandlerInputTransformer_1_0_0<K, F, E, DS>;\n  filterProcessor: (params: {filter: F | undefined; input: EthereumRuntimeHandlerInputMap[K]; ds: DS}) => boolean;\n}\n\nexport type SecondLayerHandlerProcessor<\n  K extends EthereumHandlerKind,\n  F,\n  E,\n  DS extends SubqlCustomDatasource = SubqlCustomDatasource\n> = SecondLayerHandlerProcessor_0_0_0<K, F, E, DS> | SecondLayerHandlerProcessor_1_0_0<K, F, E, DS>;\n"]}